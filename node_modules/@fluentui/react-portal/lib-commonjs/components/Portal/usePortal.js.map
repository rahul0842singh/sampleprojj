{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AAGA;;;;;;;AAOO,MAAMA,kBAAkB,GAAIC,KAAkB,IAAiB;EACpE,MAAM;IAAEC,QAAQ;IAAEC;EAAS,CAAE,GAAGF,KAAK;EAErC,MAAMG,oBAAoB,GAAGC,KAAK,CAACC,MAAM,CAAkB,IAAI,CAAC;EAChE,MAAMC,iBAAiB,GAAGC,uCAAkB,CAAC;IAAEC,QAAQ,EAAE,CAAC,CAACN;EAAS,CAAE,CAAC;EAEvE,MAAMO,KAAK,GAAgB;IACzBR,QAAQ;IACRC,SAAS,EAAEA,SAAS,aAATA,SAAS,cAATA,SAAS,GAAII,iBAAiB;IACzCH;GACD;EAEDC,KAAK,CAACM,SAAS,CAAC,MAAK;IACnB,IAAID,KAAK,CAACN,oBAAoB,CAACQ,OAAO,IAAIF,KAAK,CAACP,SAAS,EAAE;MACzDU,wBAAgB,CAACH,KAAK,CAACP,SAAS,EAAEO,KAAK,CAACN,oBAAoB,CAACQ,OAAO,CAAC;;IAEvE,OAAO,MAAK;MACV,IAAIF,KAAK,CAACP,SAAS,EAAE;QACnBU,wBAAgB,CAACH,KAAK,CAACP,SAAS,EAAEW,SAAS,CAAC;;IAEhD,CAAC;EACH,CAAC,EAAE,CAACJ,KAAK,CAACN,oBAAoB,EAAEM,KAAK,CAACP,SAAS,CAAC,CAAC;EAEjD,OAAOO,KAAK;AACd,CAAC;AAxBYK,0BAAkB","names":["usePortal_unstable","props","children","mountNode","virtualParentRootRef","React","useRef","fallbackMountNode","usePortalMountNode_1","disabled","state","useEffect","current","index_1","undefined","exports"],"sourceRoot":"../src/","sources":["packages/react-components/react-portal/src/components/Portal/usePortal.ts"],"sourcesContent":["import * as React from 'react';\nimport { usePortalMountNode } from './usePortalMountNode';\nimport { setVirtualParent } from '../../virtualParent/index';\nimport type { PortalProps, PortalState } from './Portal.types';\n\n/**\n * Create the state required to render Portal.\n *\n * The returned state can be modified with hooks such as usePortalStyles, before being passed to renderPortal_unstable.\n *\n * @param props - props from this instance of Portal\n */\nexport const usePortal_unstable = (props: PortalProps): PortalState => {\n  const { children, mountNode } = props;\n\n  const virtualParentRootRef = React.useRef<HTMLSpanElement>(null);\n  const fallbackMountNode = usePortalMountNode({ disabled: !!mountNode });\n\n  const state: PortalState = {\n    children,\n    mountNode: mountNode ?? fallbackMountNode,\n    virtualParentRootRef,\n  };\n\n  React.useEffect(() => {\n    if (state.virtualParentRootRef.current && state.mountNode) {\n      setVirtualParent(state.mountNode, state.virtualParentRootRef.current);\n    }\n    return () => {\n      if (state.mountNode) {\n        setVirtualParent(state.mountNode, undefined);\n      }\n    };\n  }, [state.virtualParentRootRef, state.mountNode]);\n\n  return state;\n};\n"]}