"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePortalMountNode = void 0;
const React = /*#__PURE__*/require("react");
const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");
const react_1 = /*#__PURE__*/require("@griffel/react");
const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");
const use_disposable_1 = /*#__PURE__*/require("use-disposable");
const useInsertionEffect = React['useInsertion' + 'Effect'];
const useStyles = /*#__PURE__*/react_1.__styles({
  root: {
    qhf8xq: "f10pi13n",
    Bj3rh1h: "f494woh"
  }
}, {
  d: [".f10pi13n{position:relative;}", ".f494woh{z-index:1000000;}"]
});
const reactMajorVersion = /*#__PURE__*/Number( /*#__PURE__*/React.version.split('.')[0]);
/**
 * Creates a new element on a document.body to mount portals
 */
const usePortalMountNode = options => {
  const {
    targetDocument,
    dir
  } = react_shared_contexts_1.useFluent_unstable();
  const focusVisibleRef = react_tabster_1.useFocusVisible();
  const classes = useStyles();
  const themeClassName = react_shared_contexts_1.useThemeClassName_unstable();
  const className = react_1.mergeClasses(themeClassName, classes.root);
  const element = use_disposable_1.useDisposable(() => {
    if (targetDocument === undefined || options.disabled) {
      return [null, () => null];
    }
    const newElement = targetDocument.createElement('div');
    targetDocument.body.appendChild(newElement);
    return [newElement, () => newElement.remove()];
  }, [targetDocument]);
  if (reactMajorVersion >= 18) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useInsertionEffect(() => {
      if (!element) {
        return;
      }
      const classesToApply = className.split(' ').filter(Boolean);
      element.classList.add(...classesToApply);
      element.setAttribute('dir', dir);
      focusVisibleRef.current = element;
      return () => {
        element.classList.remove(...classesToApply);
        element.removeAttribute('dir');
      };
    }, [className, dir, element, focusVisibleRef]);
  } else {
    // This useMemo call is intentional for React 17
    // We don't want to re-create the portal element when its attributes change.
    // This also should not be done in an effect because, changing the value of css variables
    // after initial mount can trigger interesting CSS side effects like transitions.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useMemo(() => {
      if (!element) {
        return;
      }
      // Force replace all classes
      element.className = className;
      element.setAttribute('dir', dir);
      focusVisibleRef.current = element;
    }, [className, dir, element, focusVisibleRef]);
  }
  return element;
};
exports.usePortalMountNode = usePortalMountNode;
//# sourceMappingURL=usePortalMountNode.js.map