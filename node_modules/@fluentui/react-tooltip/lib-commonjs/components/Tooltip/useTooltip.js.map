{"version":3,"mappings":"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","names":["useTooltip_unstable","props","context","react_shared_contexts_1","isServerSideRender","react_utilities_1","targetDocument","setDelayTimeout","clearDelayTimeout","appearance","children","content","withArrow","positioning","onVisibleChange","relationship","showDelay","hideDelay","mountNode","visible","setVisibleInternal","state","initialState","setVisible","React","useCallback","newVisible","ev","oldVisible","shouldRenderTooltip","components","defaultProps","role","required","id","positioningOptions","enabled","arrowPadding","constants_1","position","align","offset","react_positioning_1","targetRef","containerRef","arrowRef","ref","thisTooltip","hide","visibleTooltip","onDocumentKeyDown","key","keyboard_keys_1","stopPropagation","addEventListener","capture","undefined","removeEventListener","ignoreNextFocusEventRef","useRef","onEnterTrigger","type","current","delay","persist","onLeaveTrigger","activeElement","target","onPointerEnter","onPointerLeave","onFocus","onBlur","child","triggerAriaProps","childTargetRef","exports"],"sourceRoot":"../src/","sources":["packages/react-components/react-tooltip/src/components/Tooltip/useTooltip.tsx"],"sourcesContent":["import * as React from 'react';\nimport { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';\nimport {\n  useTooltipVisibility_unstable as useTooltipVisibility,\n  useFluent_unstable as useFluent,\n} from '@fluentui/react-shared-contexts';\nimport {\n  applyTriggerPropsToChildren,\n  resolveShorthand,\n  useControllableState,\n  useId,\n  useIsomorphicLayoutEffect,\n  useIsSSR,\n  useMergedRefs,\n  useTimeout,\n  getTriggerChild,\n  mergeCallbacks,\n  useEventCallback,\n} from '@fluentui/react-utilities';\nimport type { TooltipProps, TooltipState, TooltipChildProps } from './Tooltip.types';\nimport { arrowHeight, tooltipBorderRadius } from './private/constants';\nimport { Escape } from '@fluentui/keyboard-keys';\n\n/**\n * Create the state required to render Tooltip.\n *\n * The returned state can be modified with hooks such as useTooltipStyles_unstable,\n * before being passed to renderTooltip_unstable.\n *\n * @param props - props from this instance of Tooltip\n */\nexport const useTooltip_unstable = (props: TooltipProps): TooltipState => {\n  const context = useTooltipVisibility();\n  const isServerSideRender = useIsSSR();\n  const { targetDocument } = useFluent();\n  const [setDelayTimeout, clearDelayTimeout] = useTimeout();\n\n  const {\n    appearance = 'normal',\n    children,\n    content,\n    withArrow = false,\n    positioning = 'above',\n    onVisibleChange,\n    relationship,\n    showDelay = 250,\n    hideDelay = 250,\n    mountNode,\n  } = props;\n\n  const [visible, setVisibleInternal] = useControllableState({ state: props.visible, initialState: false });\n  const setVisible = React.useCallback(\n    (newVisible: boolean, ev?: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      clearDelayTimeout();\n      setVisibleInternal(oldVisible => {\n        if (newVisible !== oldVisible) {\n          onVisibleChange?.(ev, { visible: newVisible });\n        }\n        return newVisible;\n      });\n    },\n    [clearDelayTimeout, setVisibleInternal, onVisibleChange],\n  );\n\n  const state: TooltipState = {\n    withArrow,\n    positioning,\n    showDelay,\n    hideDelay,\n    relationship,\n    visible,\n    shouldRenderTooltip: visible,\n    appearance,\n    mountNode,\n    // Slots\n    components: {\n      content: 'div',\n    },\n    content: resolveShorthand(content, {\n      defaultProps: {\n        role: 'tooltip',\n      },\n      required: true,\n    }),\n  };\n\n  state.content.id = useId('tooltip-', state.content.id);\n\n  const positioningOptions = {\n    enabled: state.visible,\n    arrowPadding: 2 * tooltipBorderRadius,\n    position: 'above' as const,\n    align: 'center' as const,\n    offset: 4,\n    ...resolvePositioningShorthand(state.positioning),\n  };\n\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);\n  }\n\n  const {\n    targetRef,\n    containerRef,\n    arrowRef,\n  }: {\n    targetRef: React.MutableRefObject<unknown>;\n    containerRef: React.MutableRefObject<HTMLDivElement>;\n    arrowRef: React.MutableRefObject<HTMLDivElement>;\n  } = usePositioning(positioningOptions);\n\n  state.content.ref = useMergedRefs(state.content.ref, containerRef);\n  state.arrowRef = arrowRef;\n\n  // When this tooltip is visible, hide any other tooltips, and register it\n  // as the visibleTooltip with the TooltipContext.\n  // Also add a listener on document to hide the tooltip if Escape is pressed\n  useIsomorphicLayoutEffect(() => {\n    if (visible) {\n      const thisTooltip = { hide: () => setVisible(false) };\n\n      context.visibleTooltip?.hide();\n      context.visibleTooltip = thisTooltip;\n\n      const onDocumentKeyDown = (ev: KeyboardEvent) => {\n        if (ev.key === Escape) {\n          thisTooltip.hide();\n          // stop propagation to avoid conflicting with other elements that listen for `Escape`\n          // e,g: Dialog, Popover, Menu\n          ev.stopPropagation();\n        }\n      };\n\n      targetDocument?.addEventListener('keydown', onDocumentKeyDown, {\n        // As this event is added at targeted document,\n        // we need to capture the event to be sure keydown handling from tooltip happens first\n        capture: true,\n      });\n\n      return () => {\n        if (context.visibleTooltip === thisTooltip) {\n          context.visibleTooltip = undefined;\n        }\n\n        targetDocument?.removeEventListener('keydown', onDocumentKeyDown, { capture: true });\n      };\n    }\n  }, [context, targetDocument, visible, setVisible]);\n\n  // The focused element gets a blur event when the document loses focus\n  // (e.g. switching tabs in the browser), but we don't want to show the\n  // tooltip again when the document gets focus back. Handle this case by\n  // checking if the blurred element is still the document's activeElement.\n  // See https://github.com/microsoft/fluentui/issues/13541\n  const ignoreNextFocusEventRef = React.useRef(false);\n\n  // Listener for onPointerEnter and onFocus on the trigger element\n  const onEnterTrigger = React.useCallback(\n    (ev: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {\n        ignoreNextFocusEventRef.current = false;\n        return;\n      }\n\n      // Show immediately if another tooltip is already visible\n      const delay = context.visibleTooltip ? 0 : state.showDelay;\n\n      setDelayTimeout(() => {\n        setVisible(true, ev);\n      }, delay);\n\n      ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    },\n    [setDelayTimeout, setVisible, state.showDelay, context],\n  );\n\n  // Listener for onPointerLeave and onBlur on the trigger element\n  const onLeaveTrigger = React.useCallback(\n    (ev: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      let delay = state.hideDelay;\n\n      if (ev.type === 'blur') {\n        // Hide immediately when losing focus\n        delay = 0;\n\n        ignoreNextFocusEventRef.current = targetDocument?.activeElement === ev.target;\n      }\n\n      setDelayTimeout(() => {\n        setVisible(false, ev);\n      }, delay);\n\n      ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    },\n    [setDelayTimeout, setVisible, state.hideDelay, targetDocument],\n  );\n\n  // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.\n  // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.\n  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);\n  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);\n  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);\n  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);\n\n  const child = getTriggerChild(children);\n\n  const triggerAriaProps: Pick<TooltipChildProps, 'aria-label' | 'aria-labelledby' | 'aria-describedby'> = {};\n\n  if (relationship === 'label') {\n    // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.\n    if (typeof state.content.children === 'string') {\n      triggerAriaProps['aria-label'] = state.content.children;\n    } else {\n      triggerAriaProps['aria-labelledby'] = state.content.id;\n      // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element\n      state.shouldRenderTooltip = true;\n    }\n  } else if (relationship === 'description') {\n    triggerAriaProps['aria-describedby'] = state.content.id;\n    // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element\n    state.shouldRenderTooltip = true;\n  }\n\n  // Don't render the Tooltip in SSR to avoid hydration errors\n  if (isServerSideRender) {\n    state.shouldRenderTooltip = false;\n  }\n\n  const childTargetRef = useMergedRefs(child?.ref, targetRef);\n\n  // Apply the trigger props to the child, either by calling the render function, or cloning with the new props\n  state.children = applyTriggerPropsToChildren(children, {\n    ...triggerAriaProps,\n    ...child?.props,\n    // If the target prop is not provided, attach targetRef to the trigger element's ref prop\n    ref: positioningOptions.target === undefined ? childTargetRef : child?.ref,\n    onPointerEnter: useEventCallback(mergeCallbacks(child?.props?.onPointerEnter, onEnterTrigger)),\n    onPointerLeave: useEventCallback(mergeCallbacks(child?.props?.onPointerLeave, onLeaveTrigger)),\n    onFocus: useEventCallback(mergeCallbacks(child?.props?.onFocus, onEnterTrigger)),\n    onBlur: useEventCallback(mergeCallbacks(child?.props?.onBlur, onLeaveTrigger)),\n  });\n\n  return state;\n};\n"]}