"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIntersectionObserver = void 0;
const React = /*#__PURE__*/require("react");
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
const {
  useState,
  useRef
} = React;
/**
 * React hook that allows easy usage of the browser API IntersectionObserver within React
 * @param callback - A function called when the percentage of the target element is visible crosses a threshold.
 * @param options - An optional object which customizes the observer. If options isn't specified, the observer uses the
 * document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is
 * enough to trigger a callback).
 * @returns An array containing a callback to update the list of Elements the observer should listen to, a callback to
 * update the init options of the IntersectionObserver and a ref to the IntersectionObserver instance itself.
 */
const useIntersectionObserver = (callback, options) => {
  // export const useIntersectionObserver = (
  //   callback: IntersectionObserverCallback,
  //   options?: IntersectionObserverInit,
  // ): [
  //   Dispatch<SetStateAction<Element[] | undefined>>,
  //   Dispatch<SetStateAction<IntersectionObserverInit | undefined>>,
  //   MutableRefObject<IntersectionObserver | undefined>,
  // ] => {
  const observer = useRef();
  const [observerList, setObserverList] = useState();
  const [observerInit, setObserverInit] = useState(options);
  // Observer elements in passed in list and clean up previous list
  // This effect is only triggered when observerList is updated
  react_utilities_1.useIsomorphicLayoutEffect(() => {
    observer.current = new IntersectionObserver(callback, observerInit);
    // If we have an instance of IO and a list with elements, observer the elements
    if (observer.current && observerList && observerList.length > 0) {
      observerList.forEach(element => {
        var _a;
        (_a = observer.current) === null || _a === void 0 ? void 0 : _a.observe(element);
      });
    }
    // clean up previous elements being listened to
    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [observerList, observerInit, callback]);
  return {
    setObserverList,
    setObserverInit,
    observer
  };
};
exports.useIntersectionObserver = useIntersectionObserver;
//# sourceMappingURL=useIntersectionObserver.js.map