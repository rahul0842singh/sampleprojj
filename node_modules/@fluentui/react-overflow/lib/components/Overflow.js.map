{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,mBAAqBC,YAAY,QAAQ,gBAAgB;AAEzD,SAASC,2BAA2B,EAAEC,aAAa,QAAQ,2BAA2B;AAEtF,SAASC,eAAe,QAAQ,oBAAoB;AACpD,SAASC,yBAAyB,EAAEC,oBAAoB,QAAQ,yBAAyB;AACzF,SAASC,gBAAgB,EAAEC,kBAAkB,QAAQ,cAAc;AAEnE,MAAMC,SAAS,gBAAG;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;AAAA;EAAA;AAAA,EAYhB;AAWF;;;AAGA,OAAO,MAAMC,QAAQ,gBAAGV,KAAK,CAACW,UAAU,CAAC,CAACC,KAAoB,EAAEC,GAAG,KAAI;EACrE,MAAMC,MAAM,GAAGL,SAAS,EAAE;EAE1B,MAAM;IAAEM,QAAQ;IAAEC,cAAc;IAAEC,YAAY,GAAG,YAAY;IAAEC,iBAAiB;IAAEC;EAAO,CAAE,GAAGP,KAAK;EAEnG,MAAM,CAACQ,WAAW,EAAEC,cAAc,CAAC,GAAGrB,KAAK,CAACsB,QAAQ,CAAC,KAAK,CAAC;EAC3D,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGxB,KAAK,CAACsB,QAAQ,CAA0B,EAAE,CAAC;EACvF,MAAM,CAACG,eAAe,EAAEC,kBAAkB,CAAC,GAAG1B,KAAK,CAACsB,QAAQ,CAAqC,EAAE,CAAC;EAEpG;EACA;EACA,MAAMK,MAAM,GAAqBC,IAAI,IAAG;IACtCP,cAAc,CAAC,MAAMO,IAAI,CAACC,cAAc,CAACC,MAAM,GAAG,CAAC,CAAC;IACpDN,iBAAiB,CAAC,MAAK;MACrB,MAAMO,QAAQ,GAA4B,EAAE;MAC5CH,IAAI,CAACI,YAAY,CAACC,OAAO,CAACC,CAAC,IAAKH,QAAQ,CAACG,CAAC,CAACC,EAAE,CAAC,GAAG,IAAK,CAAC;MACvDP,IAAI,CAACC,cAAc,CAACI,OAAO,CAACC,CAAC,IAAKH,QAAQ,CAACG,CAAC,CAACC,EAAE,CAAC,GAAG,KAAM,CAAC;MAC1D,OAAOJ,QAAQ;IACjB,CAAC,CAAC;IACFL,kBAAkB,CAACE,IAAI,CAACH,eAAe,CAAC;EAC1C,CAAC;EAED,MAAM;IAAEW,YAAY;IAAEC,YAAY;IAAEC,cAAc;IAAEC;EAAoB,CAAE,GAAGjC,oBAAoB,CAACqB,MAAM,EAAE;IACxGT,iBAAiB;IACjBD,YAAY;IACZE,OAAO;IACPH,cAAc;IACdwB,sBAAsB,EAAEnC;GACzB,CAAC;EAEF,MAAMoC,WAAW,GAAGvC,2BAA2B,CAACa,QAAQ,EAAE;IACxDF,GAAG,EAAEV,aAAa,CAACiC,YAAY,EAAEvB,GAAG,CAAC;IACrC6B,SAAS,EAAEzC,YAAY,CAACa,MAAM,CAAC6B,YAAY,EAAE7B,MAAM,CAAC8B,gBAAgB,EAAE7B,QAAQ,CAACH,KAAK,CAAC8B,SAAS;GAC/F,CAAC;EAEF,oBACE1C,oBAACI,eAAe,CAACyC,QAAQ;IACvBC,KAAK,EAAE;MACLvB,cAAc;MACdE,eAAe;MACfL,WAAW;MACXiB,YAAY;MACZC,cAAc;MACdC;;EACD,GAEAE,WAAW,CACa;AAE/B,CAAC,CAAC","names":["React","mergeClasses","applyTriggerPropsToChildren","useMergedRefs","OverflowContext","updateVisibilityAttribute","useOverflowContainer","DATA_OVERFLOWING","DATA_OVERFLOW_MENU","useStyles","Overflow","forwardRef","props","ref","styles","children","minimumVisible","overflowAxis","overflowDirection","padding","hasOverflow","setHasOverflow","useState","itemVisibility","setItemVisibility","groupVisibility","setGroupVisibility","update","data","invisibleItems","length","newState","visibleItems","forEach","x","id","containerRef","registerItem","updateOverflow","registerOverflowMenu","onUpdateItemVisibility","clonedChild","className","overflowMenu","overflowingItems","Provider","value"],"sourceRoot":"../src/","sources":["packages/react-components/react-overflow/src/components/Overflow.tsx"],"sourcesContent":["import * as React from 'react';\nimport { makeStyles, mergeClasses } from '@griffel/react';\nimport type { OnUpdateOverflow, OverflowGroupState, ObserveOptions } from '@fluentui/priority-overflow';\nimport { applyTriggerPropsToChildren, useMergedRefs } from '@fluentui/react-utilities';\n\nimport { OverflowContext } from '../overflowContext';\nimport { updateVisibilityAttribute, useOverflowContainer } from '../useOverflowContainer';\nimport { DATA_OVERFLOWING, DATA_OVERFLOW_MENU } from '../constants';\n\nconst useStyles = makeStyles({\n  overflowMenu: {\n    [`& [${DATA_OVERFLOW_MENU}]`]: {\n      flexShrink: 0,\n    },\n  },\n\n  overflowingItems: {\n    [`& > [${DATA_OVERFLOWING}]`]: {\n      display: 'none',\n    },\n  },\n});\n\n/**\n * Overflow Props\n */\nexport type OverflowProps = Partial<\n  Pick<ObserveOptions, 'overflowAxis' | 'overflowDirection' | 'padding' | 'minimumVisible'>\n> & {\n  children: React.ReactElement;\n};\n\n/**\n * Provides an OverflowContext for OverflowItem descendants.\n */\nexport const Overflow = React.forwardRef((props: OverflowProps, ref) => {\n  const styles = useStyles();\n\n  const { children, minimumVisible, overflowAxis = 'horizontal', overflowDirection, padding } = props;\n\n  const [hasOverflow, setHasOverflow] = React.useState(false);\n  const [itemVisibility, setItemVisibility] = React.useState<Record<string, boolean>>({});\n  const [groupVisibility, setGroupVisibility] = React.useState<Record<string, OverflowGroupState>>({});\n\n  // useOverflowContainer wraps this method in a useEventCallback.\n  // TODO: Do we need a useEventCallback here too?\n  const update: OnUpdateOverflow = data => {\n    setHasOverflow(() => data.invisibleItems.length > 0);\n    setItemVisibility(() => {\n      const newState: Record<string, boolean> = {};\n      data.visibleItems.forEach(x => (newState[x.id] = true));\n      data.invisibleItems.forEach(x => (newState[x.id] = false));\n      return newState;\n    });\n    setGroupVisibility(data.groupVisibility);\n  };\n\n  const { containerRef, registerItem, updateOverflow, registerOverflowMenu } = useOverflowContainer(update, {\n    overflowDirection,\n    overflowAxis,\n    padding,\n    minimumVisible,\n    onUpdateItemVisibility: updateVisibilityAttribute,\n  });\n\n  const clonedChild = applyTriggerPropsToChildren(children, {\n    ref: useMergedRefs(containerRef, ref),\n    className: mergeClasses(styles.overflowMenu, styles.overflowingItems, children.props.className),\n  });\n\n  return (\n    <OverflowContext.Provider\n      value={{\n        itemVisibility,\n        groupVisibility,\n        hasOverflow,\n        registerItem,\n        updateOverflow,\n        registerOverflowMenu,\n      }}\n    >\n      {clonedChild}\n    </OverflowContext.Provider>\n  );\n});\n"]}