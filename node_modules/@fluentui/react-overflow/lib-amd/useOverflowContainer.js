define(["require", "exports", "react", "@fluentui/priority-overflow", "@fluentui/react-utilities", "./constants"], function (require, exports, React, priority_overflow_1, react_utilities_1, constants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateVisibilityAttribute = exports.useOverflowContainer = void 0;
    /**
     * @internal
     * @param update - Callback when overflow state changes
     * @param options - Options to configure the overflow container
     * @returns - ref to attach to an intrinsic HTML element and imperative functions
     */
    var useOverflowContainer = function (update, options) {
        var overflowAxis = options.overflowAxis, overflowDirection = options.overflowDirection, padding = options.padding, minimumVisible = options.minimumVisible, onUpdateItemVisibility = options.onUpdateItemVisibility;
        // DOM ref to the overflow container element
        var containerRef = React.useRef(null);
        var updateOverflowItems = react_utilities_1.useEventCallback(update);
        var overflowManager = React.useState(function () {
            return react_utilities_1.canUseDOM() ? priority_overflow_1.createOverflowManager() : null;
        })[0];
        react_utilities_1.useIsomorphicLayoutEffect(function () {
            if (!containerRef.current) {
                return;
            }
            if (overflowManager) {
                overflowManager.observe(containerRef.current, {
                    overflowDirection: overflowDirection !== null && overflowDirection !== void 0 ? overflowDirection : 'end',
                    overflowAxis: overflowAxis !== null && overflowAxis !== void 0 ? overflowAxis : 'horizontal',
                    padding: padding !== null && padding !== void 0 ? padding : 10,
                    minimumVisible: minimumVisible !== null && minimumVisible !== void 0 ? minimumVisible : 0,
                    onUpdateItemVisibility: onUpdateItemVisibility !== null && onUpdateItemVisibility !== void 0 ? onUpdateItemVisibility : (function () { return undefined; }),
                    onUpdateOverflow: updateOverflowItems !== null && updateOverflowItems !== void 0 ? updateOverflowItems : (function () { return undefined; }),
                });
                return function () {
                    overflowManager.disconnect();
                };
            }
        }, [
            updateOverflowItems,
            overflowManager,
            overflowDirection,
            overflowAxis,
            padding,
            minimumVisible,
            onUpdateItemVisibility,
        ]);
        var registerItem = React.useCallback(function (item) {
            overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addItem(item);
            item.element.setAttribute(constants_1.DATA_OVERFLOW_ITEM, '');
            return function () {
                item.element.removeAttribute(constants_1.DATA_OVERFLOWING);
                item.element.removeAttribute(constants_1.DATA_OVERFLOW_ITEM);
                overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeItem(item.id);
            };
        }, [overflowManager]);
        var updateOverflow = React.useCallback(function () {
            overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.update();
        }, [overflowManager]);
        var registerOverflowMenu = React.useCallback(function (el) {
            overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addOverflowMenu(el);
            el.setAttribute(constants_1.DATA_OVERFLOW_MENU, '');
            return function () {
                overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeOverflowMenu();
                el.removeAttribute(constants_1.DATA_OVERFLOW_MENU);
            };
        }, [overflowManager]);
        return {
            containerRef: containerRef,
            registerItem: registerItem,
            updateOverflow: updateOverflow,
            registerOverflowMenu: registerOverflowMenu,
        };
    };
    exports.useOverflowContainer = useOverflowContainer;
    var updateVisibilityAttribute = function (_a) {
        var item = _a.item, visible = _a.visible;
        if (visible) {
            item.element.removeAttribute(constants_1.DATA_OVERFLOWING);
        }
        else {
            item.element.setAttribute(constants_1.DATA_OVERFLOWING, '');
        }
    };
    exports.updateVisibilityAttribute = updateVisibilityAttribute;
});
//# sourceMappingURL=useOverflowContainer.js.map