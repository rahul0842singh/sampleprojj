define(["require", "exports", "react", "@griffel/react", "@fluentui/react-utilities", "../overflowContext", "../useOverflowContainer", "../constants"], function (require, exports, React, react_1, react_utilities_1, overflowContext_1, useOverflowContainer_1, constants_1) {
    "use strict";
    var _a, _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Overflow = void 0;
    var useStyles = react_1.makeStyles({
        overflowMenu: (_a = {},
            _a["& [" + constants_1.DATA_OVERFLOW_MENU + "]"] = {
                flexShrink: 0,
            },
            _a),
        overflowingItems: (_b = {},
            _b["& > [" + constants_1.DATA_OVERFLOWING + "]"] = {
                display: 'none',
            },
            _b),
    });
    /**
     * Provides an OverflowContext for OverflowItem descendants.
     */
    exports.Overflow = React.forwardRef(function (props, ref) {
        var styles = useStyles();
        var children = props.children, minimumVisible = props.minimumVisible, _a = props.overflowAxis, overflowAxis = _a === void 0 ? 'horizontal' : _a, overflowDirection = props.overflowDirection, padding = props.padding;
        var _b = React.useState(false), hasOverflow = _b[0], setHasOverflow = _b[1];
        var _c = React.useState({}), itemVisibility = _c[0], setItemVisibility = _c[1];
        var _d = React.useState({}), groupVisibility = _d[0], setGroupVisibility = _d[1];
        // useOverflowContainer wraps this method in a useEventCallback.
        // TODO: Do we need a useEventCallback here too?
        var update = function (data) {
            setHasOverflow(function () { return data.invisibleItems.length > 0; });
            setItemVisibility(function () {
                var newState = {};
                data.visibleItems.forEach(function (x) { return (newState[x.id] = true); });
                data.invisibleItems.forEach(function (x) { return (newState[x.id] = false); });
                return newState;
            });
            setGroupVisibility(data.groupVisibility);
        };
        var _e = useOverflowContainer_1.useOverflowContainer(update, {
            overflowDirection: overflowDirection,
            overflowAxis: overflowAxis,
            padding: padding,
            minimumVisible: minimumVisible,
            onUpdateItemVisibility: useOverflowContainer_1.updateVisibilityAttribute,
        }), containerRef = _e.containerRef, registerItem = _e.registerItem, updateOverflow = _e.updateOverflow, registerOverflowMenu = _e.registerOverflowMenu;
        var clonedChild = react_utilities_1.applyTriggerPropsToChildren(children, {
            ref: react_utilities_1.useMergedRefs(containerRef, ref),
            className: react_1.mergeClasses(styles.overflowMenu, styles.overflowingItems, children.props.className),
        });
        return (React.createElement(overflowContext_1.OverflowContext.Provider, { value: {
                itemVisibility: itemVisibility,
                groupVisibility: groupVisibility,
                hasOverflow: hasOverflow,
                registerItem: registerItem,
                updateOverflow: updateOverflow,
                registerOverflowMenu: registerOverflowMenu,
            } }, clonedChild));
    });
});
//# sourceMappingURL=Overflow.js.map