define(["require", "exports", "react", "@fluentui/react-shared-contexts", "./useTabster"], function (require, exports, React, react_shared_contexts_1, useTabster_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useFocusFinders = void 0;
    /**
     * Returns a set of helper functions that will traverse focusable elements in the context of a root DOM element
     */
    var useFocusFinders = function () {
        var tabster = useTabster_1.useTabster();
        var targetDocument = react_shared_contexts_1.useFluent_unstable().targetDocument;
        // Narrow props for now and let need dictate additional props in the future
        var findAllFocusable = React.useCallback(function (container, acceptCondition) {
            return (tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findAll({ container: container, acceptCondition: acceptCondition })) || [];
        }, [tabster]);
        var findFirstFocusable = React.useCallback(function (container) { return tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findFirst({ container: container }); }, [tabster]);
        var findLastFocusable = React.useCallback(function (container) { return tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findLast({ container: container }); }, [
            tabster,
        ]);
        var findNextFocusable = React.useCallback(function (currentElement, options) {
            if (options === void 0) { options = {}; }
            if (!tabster || !targetDocument) {
                return null;
            }
            var _a = options.container, container = _a === void 0 ? targetDocument.body : _a;
            return tabster.focusable.findNext({ currentElement: currentElement, container: container });
        }, [tabster, targetDocument]);
        var findPrevFocusable = React.useCallback(function (currentElement, options) {
            if (options === void 0) { options = {}; }
            if (!tabster || !targetDocument) {
                return null;
            }
            var _a = options.container, container = _a === void 0 ? targetDocument.body : _a;
            return tabster.focusable.findPrev({ currentElement: currentElement, container: container });
        }, [tabster, targetDocument]);
        return {
            findAllFocusable: findAllFocusable,
            findFirstFocusable: findFirstFocusable,
            findLastFocusable: findLastFocusable,
            findNextFocusable: findNextFocusable,
            findPrevFocusable: findPrevFocusable,
        };
    };
    exports.useFocusFinders = useFocusFinders;
});
//# sourceMappingURL=useFocusFinders.js.map