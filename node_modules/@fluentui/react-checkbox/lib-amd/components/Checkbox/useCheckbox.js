define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/react-icons", "@fluentui/react-label", "@fluentui/react-tabster"], function (require, exports, tslib_1, React, react_utilities_1, react_icons_1, react_label_1, react_tabster_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCheckbox_unstable = void 0;
    /**
     * Create the state required to render Checkbox.
     *
     * The returned state can be modified with hooks such as useCheckboxStyles_unstable,
     * before being passed to renderCheckbox_unstable.
     *
     * @param props - props from this instance of Checkbox
     * @param ref - reference to `<input>` element of Checkbox
     */
    var useCheckbox_unstable = function (props, ref) {
        var _a = props.disabled, disabled = _a === void 0 ? false : _a, required = props.required, _b = props.shape, shape = _b === void 0 ? 'square' : _b, _c = props.size, size = _c === void 0 ? 'medium' : _c, _d = props.labelPosition, labelPosition = _d === void 0 ? 'after' : _d, onChange = props.onChange;
        var _e = react_utilities_1.useControllableState({
            defaultState: props.defaultChecked,
            state: props.checked,
            initialState: false,
        }), checked = _e[0], setChecked = _e[1];
        var nativeProps = react_utilities_1.getPartitionedNativeProps({
            props: props,
            primarySlotTagName: 'input',
            excludedPropNames: ['checked', 'defaultChecked', 'size', 'onChange'],
        });
        var mixed = checked === 'mixed';
        var id = react_utilities_1.useId('checkbox-', nativeProps.primary.id);
        var checkmarkIcon;
        if (mixed) {
            if (shape === 'circular') {
                checkmarkIcon = React.createElement(react_icons_1.CircleFilled, null);
            }
            else {
                checkmarkIcon = size === 'large' ? React.createElement(react_icons_1.Square16Filled, null) : React.createElement(react_icons_1.Square12Filled, null);
            }
        }
        else if (checked) {
            checkmarkIcon = size === 'large' ? React.createElement(react_icons_1.Checkmark16Filled, null) : React.createElement(react_icons_1.Checkmark12Filled, null);
        }
        var state = {
            shape: shape,
            checked: checked,
            disabled: disabled,
            size: size,
            labelPosition: labelPosition,
            components: {
                root: 'span',
                input: 'input',
                indicator: 'div',
                label: react_label_1.Label,
            },
            root: react_utilities_1.resolveShorthand(props.root, {
                required: true,
                defaultProps: tslib_1.__assign({ ref: react_tabster_1.useFocusWithin() }, nativeProps.root),
            }),
            input: react_utilities_1.resolveShorthand(props.input, {
                required: true,
                defaultProps: tslib_1.__assign({ type: 'checkbox', id: id, ref: ref, checked: checked === true }, nativeProps.primary),
            }),
            label: react_utilities_1.resolveShorthand(props.label, {
                required: false,
                defaultProps: {
                    htmlFor: id,
                    disabled: disabled,
                    required: required,
                    size: 'medium', // Even if the checkbox itself is large
                },
            }),
            indicator: react_utilities_1.resolveShorthand(props.indicator, {
                required: true,
                defaultProps: {
                    'aria-hidden': true,
                    children: checkmarkIcon,
                },
            }),
        };
        state.input.onChange = react_utilities_1.useEventCallback(function (ev) {
            var val = ev.currentTarget.indeterminate ? 'mixed' : ev.currentTarget.checked;
            onChange === null || onChange === void 0 ? void 0 : onChange(ev, { checked: val });
            setChecked(val);
        });
        // Create a ref object for the input element so we can use it to set the indeterminate prop.
        // Use useMergedRefs, since the ref might be undefined or a function-ref (no .current)
        var inputRef = react_utilities_1.useMergedRefs(state.input.ref);
        state.input.ref = inputRef;
        // Set the <input> element's checked and indeterminate properties based on our tri-state property.
        // Since indeterminate can only be set via javascript, it has to be done in a layout effect.
        react_utilities_1.useIsomorphicLayoutEffect(function () {
            if (inputRef.current) {
                inputRef.current.indeterminate = mixed;
            }
        }, [inputRef, mixed]);
        return state;
    };
    exports.useCheckbox_unstable = useCheckbox_unstable;
});
//# sourceMappingURL=useCheckbox.js.map