{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AAGA;;;AAGaA,wBAAgB,GAAG,cAAc;AAE9C;;;;;;;;;;;AAWO,MAAMC,mBAAmB,GAAIC,OAAyC,IAAI;EAC/E,MAAM;IAAEC,IAAI;IAAEC,QAAQ;IAAEC,OAAO;IAAEC;EAAQ,CAAE,GAAGJ,OAAO;EAErD;EACA,MAAMK,QAAQ,GAAGC,kCAAgB,CAAEC,EAAc,IAAI;;IACnD,MAAMC,UAAU,GAAGP,IAAI,CAAC,CAAC,CAAC;IAC1B,MAAMQ,eAAe,GAAGF,EAAE,CAACG,MAAqB;IAEhD;IACA;IACA;IACA,MAAMC,gBAAgB,GAAG,CAACC,8BAAe,CAAC,gBAAU,CAACC,OAAO,mCAAI,IAAI,EAAEJ,eAAe,CAAC;IACtF,IAAIE,gBAAgB,IAAI,CAACP,QAAQ,EAAE;MACjCF,QAAQ,CAACK,EAAE,CAAC;;EAEhB,CAAC,CAAC;EAEFO,KAAK,CAACC,SAAS,CAAC,MAAK;IACnB;IACA,IAAIZ,OAAO,IAAI,IAAI,EAAE;MACnB;;IAWF,IAAI,CAACC,QAAQ,EAAE;MACbD,OAAO,CAACa,gBAAgB,CAAClB,wBAAgB,EAAEO,QAA4B,CAAC;;IAG1E,OAAO,MAAK;MACVF,OAAO,CAACc,mBAAmB,CAACnB,wBAAgB,EAAEO,QAA4B,CAAC;IAC7E,CAAC;EACH,CAAC,EAAE,CAACA,QAAQ,EAAEF,OAAO,EAAEC,QAAQ,CAAC,CAAC;AACnC,CAAC;AAvCYN,2BAAmB;AAyChC;;;;;AAKO,MAAMoB,sBAAsB,GAAG,CAACC,EAAe,EAAEC,WAAuB,KAAI;EACjFD,EAAE,CAACE,aAAa,CAAC,IAAIC,WAAW,CAACxB,wBAAgB,EAAE;IAAEyB,OAAO,EAAE,IAAI;IAAEC,MAAM,EAAE;MAAEJ;IAAW;EAAE,CAAE,CAAC,CAAC;AACjG,CAAC;AAFYtB,8BAAsB","names":["exports","useOnMenuMouseEnter","options","refs","callback","element","disabled","listener","react_utilities_1","ev","popoverRef","someMenuPopover","target","isOutsidePopover","react_portal_1","current","React","useEffect","addEventListener","removeEventListener","dispatchMenuEnterEvent","el","nativeEvent","dispatchEvent","CustomEvent","bubbles","detail"],"sourceRoot":"../src/","sources":["packages/react-components/react-menu/src/utils/useOnMenuEnter.ts"],"sourcesContent":["import * as React from 'react';\nimport { useEventCallback } from '@fluentui/react-utilities';\nimport { elementContains } from '@fluentui/react-portal';\nimport type { UseOnClickOrScrollOutsideOptions } from '@fluentui/react-utilities';\n\n/**\n * Name of the custom event\n */\nexport const MENU_ENTER_EVENT = 'fuimenuenter';\n\n/**\n * This hook works similarly to @see {useOnClickOutside}\n *\n * Problem: Trying to behave the same as system menus:\n * When the mouse leaves a stack of nested menus the stack should not dismiss.\n * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.\n *\n * We don't use the native mouseenter event because it would trigger too many times in the document\n * Instead, dispatch custom DOM event from the menu so that it can bubble\n * Each nested menu can use the listener to check if the event is from a child or parent menu\n */\nexport const useOnMenuMouseEnter = (options: UseOnClickOrScrollOutsideOptions) => {\n  const { refs, callback, element, disabled } = options;\n\n  // Keep mouse event here because this is essentially a custom 'mouseenter' event\n  const listener = useEventCallback((ev: MouseEvent) => {\n    const popoverRef = refs[0];\n    const someMenuPopover = ev.target as HTMLElement;\n\n    // someMenu is a child -> will always be contained because of vParents\n    // someMenu is a parent -> will always not be contained because no vParent\n    // someMenu is the current popover -> it will contain itself\n    const isOutsidePopover = !elementContains(popoverRef.current ?? null, someMenuPopover);\n    if (isOutsidePopover && !disabled) {\n      callback(ev);\n    }\n  });\n\n  React.useEffect(() => {\n    // eslint-disable-next-line eqeqeq\n    if (element == null) {\n      return;\n    }\n\n    /**\n     * Because `addEventListener` type override falls back to 2nd definition (evt name is unknown string literal)\n     * evt is being typed as a base class of MouseEvent -> `Event`.\n     * This type is used to override `listener` calls to make TS happy\n     */\n\n    type ListenerOverride = (evt: Event) => void;\n\n    if (!disabled) {\n      element.addEventListener(MENU_ENTER_EVENT, listener as ListenerOverride);\n    }\n\n    return () => {\n      element.removeEventListener(MENU_ENTER_EVENT, listener as ListenerOverride);\n    };\n  }, [listener, element, disabled]);\n};\n\n/**\n * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`\n * @param el element for the event target\n * @param nativeEvent the native mouse event this is mapped to\n */\nexport const dispatchMenuEnterEvent = (el: HTMLElement, nativeEvent: MouseEvent) => {\n  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, { bubbles: true, detail: { nativeEvent } }));\n};\n"]}