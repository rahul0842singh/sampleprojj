define(["require", "exports", "tslib", "react"], function (require, exports, tslib_1, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useOptionCollection = void 0;
    /**
     * A hook for managing a collection of child Options
     */
    var useOptionCollection = function () {
        var nodes = React.useRef([]);
        var collectionAPI = React.useMemo(function () {
            var getCount = function () { return nodes.current.length; };
            var getOptionAtIndex = function (index) { var _a; return (_a = nodes.current[index]) === null || _a === void 0 ? void 0 : _a.option; };
            var getIndexOfId = function (id) { return nodes.current.findIndex(function (node) { return node.option.id === id; }); };
            var getOptionById = function (id) {
                var item = nodes.current.find(function (node) { return node.option.id === id; });
                return item === null || item === void 0 ? void 0 : item.option;
            };
            var getOptionsMatchingText = function (matcher) {
                return nodes.current.filter(function (node) { return matcher(node.option.text); }).map(function (node) { return node.option; });
            };
            var getOptionsMatchingValue = function (matcher) {
                return nodes.current.filter(function (node) { return matcher(node.option.value); }).map(function (node) { return node.option; });
            };
            return {
                getCount: getCount,
                getOptionAtIndex: getOptionAtIndex,
                getIndexOfId: getIndexOfId,
                getOptionById: getOptionById,
                getOptionsMatchingText: getOptionsMatchingText,
                getOptionsMatchingValue: getOptionsMatchingValue,
            };
        }, []);
        var registerOption = React.useCallback(function (option, element) {
            var _a;
            var index = nodes.current.findIndex(function (node) {
                if (!node.element || !element) {
                    return false;
                }
                if (node.option.id === option.id) {
                    return true;
                }
                // use the DOM method compareDocumentPosition to order the current node against registered nodes
                // eslint-disable-next-line no-bitwise
                return node.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING;
            });
            // do not register the option if it already exists
            if (((_a = nodes.current[index]) === null || _a === void 0 ? void 0 : _a.option.id) !== option.id) {
                var newItem = {
                    element: element,
                    option: option,
                };
                // If an index is not found we will push the element to the end.
                if (index === -1) {
                    nodes.current = tslib_1.__spreadArray(tslib_1.__spreadArray([], nodes.current), [newItem]);
                }
                else {
                    nodes.current.splice(index, 0, newItem);
                }
            }
            // return the unregister function
            return function () {
                nodes.current = nodes.current.filter(function (node) { return node.option.id !== option.id; });
            };
        }, []);
        return tslib_1.__assign(tslib_1.__assign({}, collectionAPI), { options: nodes.current.map(function (node) { return node.option; }), registerOption: registerOption });
    };
    exports.useOptionCollection = useOptionCollection;
});
//# sourceMappingURL=useOptionCollection.js.map