define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "../utils/dropdownKeyActions"], function (require, exports, tslib_1, React, react_utilities_1, dropdownKeyActions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTriggerListboxSlots = void 0;
    /*
     * useTriggerListboxSlots returns a tuple of trigger/listbox shorthand,
     * with the semantics and event handlers needed for the Combobox and Dropdown components.
     * The element type of the ref should always match the element type used in the trigger shorthand.
     */
    function useTriggerListboxSlots(props, state, ref, triggerSlot, listboxSlot) {
        var multiselect = props.multiselect;
        var activeOption = state.activeOption, getCount = state.getCount, getIndexOfId = state.getIndexOfId, getOptionAtIndex = state.getOptionAtIndex, ignoreNextBlur = state.ignoreNextBlur, open = state.open, selectOption = state.selectOption, setActiveOption = state.setActiveOption, setFocusVisible = state.setFocusVisible, setHasFocus = state.setHasFocus, setOpen = state.setOpen;
        // handle trigger focus/blur
        var triggerRef = React.useRef(null);
        // resolve listbox shorthand props
        var listboxId = react_utilities_1.useId('fluent-listbox', listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id);
        var listbox = listboxSlot && tslib_1.__assign({ id: listboxId, multiselect: multiselect, tabIndex: undefined }, listboxSlot);
        // resolve trigger shorthand props
        var trigger = tslib_1.__assign(tslib_1.__assign({ 'aria-expanded': open, 'aria-activedescendant': open ? activeOption === null || activeOption === void 0 ? void 0 : activeOption.id : undefined, role: 'combobox' }, triggerSlot), { 
            // explicitly type the ref as an intersection here to prevent type errors
            // since the `children` prop has mutually incompatible types between input/button
            // functionally both ref and triggerRef will always be the same element type
            ref: react_utilities_1.useMergedRefs(ref, triggerSlot === null || triggerSlot === void 0 ? void 0 : triggerSlot.ref, triggerRef) });
        /*
         * Handle focus when clicking the listbox popup:
         * 1. Move focus back to the button/input when the listbox is clicked (otherwise it goes to body)
         * 2. Do not close the listbox on button/input blur when clicking into the listbox
         */
        var listboxOnClick = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(function (event) {
            var _a;
            (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }, listbox === null || listbox === void 0 ? void 0 : listbox.onClick));
        var listboxOnMouseOver = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(function (event) {
            setFocusVisible(false);
        }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseOver));
        var listboxOnMouseDown = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(function (event) {
            ignoreNextBlur.current = true;
        }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseDown));
        // listbox is nullable, only add event handlers if it exists
        if (listbox) {
            listbox.onClick = listboxOnClick;
            listbox.onMouseOver = listboxOnMouseOver;
            listbox.onMouseDown = listboxOnMouseDown;
        }
        // the trigger should open/close the popup on click or blur
        trigger.onBlur = react_utilities_1.mergeCallbacks(function (event) {
            if (!ignoreNextBlur.current) {
                setOpen(event, false);
            }
            ignoreNextBlur.current = false;
            setHasFocus(false);
        }, trigger.onBlur);
        trigger.onClick = react_utilities_1.mergeCallbacks(function (event) {
            setOpen(event, !open);
        }, trigger.onClick);
        trigger.onFocus = react_utilities_1.mergeCallbacks(function (event) {
            setHasFocus(true);
        }, trigger.onFocus);
        // handle combobox keyboard interaction
        trigger.onKeyDown = react_utilities_1.mergeCallbacks(function (event) {
            var action = dropdownKeyActions_1.getDropdownActionFromKey(event, { open: open, multiselect: multiselect });
            var maxIndex = getCount() - 1;
            var activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
            var newIndex = activeIndex;
            switch (action) {
                case 'Open':
                    event.preventDefault();
                    setFocusVisible(true);
                    setOpen(event, true);
                    break;
                case 'Close':
                    // stop propagation for escape key to avoid dismissing any parent popups
                    event.stopPropagation();
                    event.preventDefault();
                    setOpen(event, false);
                    break;
                case 'CloseSelect':
                    !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(event, false);
                // fallthrough
                case 'Select':
                    activeOption && selectOption(event, activeOption);
                    event.preventDefault();
                    break;
                case 'Tab':
                    !multiselect && activeOption && selectOption(event, activeOption);
                    break;
                default:
                    newIndex = dropdownKeyActions_1.getIndexFromAction(action, activeIndex, maxIndex);
            }
            if (newIndex !== activeIndex) {
                // prevent default page scroll/keyboard action if the index changed
                event.preventDefault();
                setActiveOption(getOptionAtIndex(newIndex));
                setFocusVisible(true);
            }
        }, trigger.onKeyDown);
        trigger.onMouseOver = react_utilities_1.mergeCallbacks(function (event) {
            setFocusVisible(false);
        }, trigger.onMouseOver);
        return [trigger, listbox];
    }
    exports.useTriggerListboxSlots = useTriggerListboxSlots;
});
//# sourceMappingURL=useTriggerListboxSlots.js.map