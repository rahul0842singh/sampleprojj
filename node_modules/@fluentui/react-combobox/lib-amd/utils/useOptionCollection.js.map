{"version":3,"file":"useOptionCollection.js","sourceRoot":"","sources":["../../../../../../../../packages/react-components/react-combobox/src/utils/useOptionCollection.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport type { OptionCollectionState, OptionValue } from './OptionCollection.types';\n\n/**\n * A hook for managing a collection of child Options\n */\nexport const useOptionCollection = (): OptionCollectionState => {\n  const nodes = React.useRef<{ option: OptionValue; element: HTMLElement }[]>([]);\n\n  const collectionAPI = React.useMemo(() => {\n    const getCount = () => nodes.current.length;\n    const getOptionAtIndex = (index: number) => nodes.current[index]?.option;\n    const getIndexOfId = (id: string) => nodes.current.findIndex(node => node.option.id === id);\n    const getOptionById = (id: string) => {\n      const item = nodes.current.find(node => node.option.id === id);\n      return item?.option;\n    };\n    const getOptionsMatchingText = (matcher: (text: string) => boolean) => {\n      return nodes.current.filter(node => matcher(node.option.text)).map(node => node.option);\n    };\n    const getOptionsMatchingValue = (matcher: (value: string) => boolean) => {\n      return nodes.current.filter(node => matcher(node.option.value)).map(node => node.option);\n    };\n\n    return {\n      getCount,\n      getOptionAtIndex,\n      getIndexOfId,\n      getOptionById,\n      getOptionsMatchingText,\n      getOptionsMatchingValue,\n    };\n  }, []);\n\n  const registerOption = React.useCallback((option: OptionValue, element: HTMLElement) => {\n    const index = nodes.current.findIndex(node => {\n      if (!node.element || !element) {\n        return false;\n      }\n\n      if (node.option.id === option.id) {\n        return true;\n      }\n\n      // use the DOM method compareDocumentPosition to order the current node against registered nodes\n      // eslint-disable-next-line no-bitwise\n      return node.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING;\n    });\n\n    // do not register the option if it already exists\n    if (nodes.current[index]?.option.id !== option.id) {\n      const newItem = {\n        element,\n        option,\n      };\n\n      // If an index is not found we will push the element to the end.\n      if (index === -1) {\n        nodes.current = [...nodes.current, newItem];\n      } else {\n        nodes.current.splice(index, 0, newItem);\n      }\n    }\n\n    // return the unregister function\n    return () => {\n      nodes.current = nodes.current.filter(node => node.option.id !== option.id);\n    };\n  }, []);\n\n  return {\n    ...collectionAPI,\n    options: nodes.current.map(node => node.option),\n    registerOption,\n  };\n};\n"]}