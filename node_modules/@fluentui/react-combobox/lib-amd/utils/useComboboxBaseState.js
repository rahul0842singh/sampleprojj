define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "../utils/useOptionCollection", "../utils/useSelection"], function (require, exports, tslib_1, React, react_utilities_1, useOptionCollection_1, useSelection_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useComboboxBaseState = void 0;
    /**
     * State shared between Combobox and Dropdown components
     */
    var useComboboxBaseState = function (props) {
        var _a = props.appearance, appearance = _a === void 0 ? 'outline' : _a, children = props.children, _b = props.editable, editable = _b === void 0 ? false : _b, _c = props.inlinePopup, inlinePopup = _c === void 0 ? false : _c, multiselect = props.multiselect, onOpenChange = props.onOpenChange, _d = props.size, size = _d === void 0 ? 'medium' : _d;
        var optionCollection = useOptionCollection_1.useOptionCollection();
        var getOptionAtIndex = optionCollection.getOptionAtIndex, getOptionsMatchingValue = optionCollection.getOptionsMatchingValue;
        var _e = React.useState(), activeOption = _e[0], setActiveOption = _e[1];
        // track whether keyboard focus outline should be shown
        // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move
        var _f = React.useState(false), focusVisible = _f[0], setFocusVisible = _f[1];
        // track focused state to conditionally render collapsed listbox
        var _g = React.useState(false), hasFocus = _g[0], setHasFocus = _g[1];
        var ignoreNextBlur = React.useRef(false);
        var selectionState = useSelection_1.useSelection(props);
        var selectedOptions = selectionState.selectedOptions;
        // calculate value based on props, internal value changes, and selected options
        var isFirstMount = react_utilities_1.useFirstMount();
        var _h = react_utilities_1.useControllableState({
            state: props.value,
            initialState: undefined,
        }), controllableValue = _h[0], setValue = _h[1];
        var value = React.useMemo(function () {
            // don't compute the value if it is defined through props or setValue,
            if (controllableValue !== undefined) {
                return controllableValue;
            }
            // handle defaultValue here, so it is overridden by selection
            if (isFirstMount && props.defaultValue !== undefined) {
                return props.defaultValue;
            }
            var selectedOptionsText = getOptionsMatchingValue(function (optionValue) {
                return selectedOptions.includes(optionValue);
            }).map(function (option) { return option.text; });
            if (multiselect) {
                // editable inputs should not display multiple selected options in the input as text
                return editable ? '' : selectedOptionsText.join(', ');
            }
            return selectedOptionsText[0];
            // do not change value after isFirstMount changes,
            // we do not want to accidentally override defaultValue on a second render
            // unless another value is intentionally set
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [controllableValue, editable, getOptionsMatchingValue, multiselect, props.defaultValue, selectedOptions]);
        // Handle open state, which is shared with options in context
        var _j = react_utilities_1.useControllableState({
            state: props.open,
            defaultState: props.defaultOpen,
            initialState: false,
        }), open = _j[0], setOpenState = _j[1];
        var setOpen = React.useCallback(function (event, newState) {
            onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, { open: newState });
            setOpenState(newState);
        }, [onOpenChange, setOpenState]);
        // update active option based on change in open state or children
        React.useEffect(function () {
            if (open && !activeOption) {
                // if it is single-select and there is a selected option, start at the selected option
                if (!multiselect && selectedOptions.length > 0) {
                    var selectedOption = getOptionsMatchingValue(function (v) { return v === selectedOptions[0]; }).pop();
                    selectedOption && setActiveOption(selectedOption);
                }
                // default to starting at the first option
                else {
                    setActiveOption(getOptionAtIndex(0));
                }
            }
            else if (!open) {
                // reset the active option when closing
                setActiveOption(undefined);
            }
            // this should only be run in response to changes in the open state or children
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [open, children]);
        return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, optionCollection), selectionState), { activeOption: activeOption, appearance: appearance, focusVisible: focusVisible, hasFocus: hasFocus, ignoreNextBlur: ignoreNextBlur, inlinePopup: inlinePopup, open: open, setActiveOption: setActiveOption, setFocusVisible: setFocusVisible, setHasFocus: setHasFocus, setOpen: setOpen, setValue: setValue, size: size, value: value });
    };
    exports.useComboboxBaseState = useComboboxBaseState;
});
//# sourceMappingURL=useComboboxBaseState.js.map