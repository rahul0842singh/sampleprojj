define(["require", "exports", "tslib", "react", "@fluentui/keyboard-keys", "@fluentui/react-icons", "@fluentui/react-utilities", "../../utils/dropdownKeyActions", "../../utils/useComboboxBaseState", "../../utils/useComboboxPopup", "../../utils/useTriggerListboxSlots", "../Listbox/Listbox"], function (require, exports, tslib_1, React, keyboard_keys_1, react_icons_1, react_utilities_1, dropdownKeyActions_1, useComboboxBaseState_1, useComboboxPopup_1, useTriggerListboxSlots_1, Listbox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCombobox_unstable = void 0;
    /**
     * Create the state required to render Combobox.
     *
     * The returned state can be modified with hooks such as useComboboxStyles_unstable,
     * before being passed to renderCombobox_unstable.
     *
     * @param props - props from this instance of Combobox
     * @param ref - reference to root HTMLElement of Combobox
     */
    var useCombobox_unstable = function (props, ref) {
        var _a, _b;
        var _c, _d;
        var baseState = useComboboxBaseState_1.useComboboxBaseState(tslib_1.__assign(tslib_1.__assign({}, props), { editable: true }));
        var activeOption = baseState.activeOption, clearSelection = baseState.clearSelection, getIndexOfId = baseState.getIndexOfId, getOptionsMatchingText = baseState.getOptionsMatchingText, hasFocus = baseState.hasFocus, open = baseState.open, selectOption = baseState.selectOption, selectedOptions = baseState.selectedOptions, setActiveOption = baseState.setActiveOption, setFocusVisible = baseState.setFocusVisible, setOpen = baseState.setOpen, setValue = baseState.setValue, value = baseState.value;
        var disabled = props.disabled, freeform = props.freeform, inlinePopup = props.inlinePopup, multiselect = props.multiselect;
        var comboId = react_utilities_1.useId('combobox-');
        var _e = react_utilities_1.getPartitionedNativeProps({
            props: props,
            primarySlotTagName: 'input',
            excludedPropNames: ['children', 'size'],
        }), triggerNativeProps = _e.primary, rootNativeProps = _e.root;
        var rootRef = React.useRef(null);
        var triggerRef = React.useRef(null);
        // NVDA and JAWS have bugs that suppress reading the input value text when aria-activedescendant is set
        // To prevent this, we clear the HTML attribute (but save the state) when a user presses left/right arrows
        // ref: https://github.com/microsoft/fluentui/issues/26359#issuecomment-1397759888
        var _f = React.useState(false), hideActiveDescendant = _f[0], setHideActiveDescendant = _f[1];
        // calculate listbox width style based on trigger width
        var _g = React.useState(), popupDimensions = _g[0], setPopupDimensions = _g[1];
        React.useEffect(function () {
            var _a;
            // only recalculate width when opening
            if (open) {
                var width = ((_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) + "px";
                if (width !== (popupDimensions === null || popupDimensions === void 0 ? void 0 : popupDimensions.width)) {
                    setPopupDimensions({ width: width });
                }
            }
        }, [open, popupDimensions]);
        // set active option and selection based on typing
        var getOptionFromInput = function (inputValue) {
            var _a;
            var searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();
            if (!searchString || searchString.length === 0) {
                return;
            }
            var matcher = function (optionText) { return optionText.toLowerCase().indexOf(searchString) === 0; };
            var matches = getOptionsMatchingText(matcher);
            // return first matching option after the current active option, looping back to the top
            if (matches.length > 1 && activeOption) {
                var startIndex_1 = getIndexOfId(activeOption.id);
                var nextMatch = matches.find(function (option) { return getIndexOfId(option.id) >= startIndex_1; });
                return nextMatch !== null && nextMatch !== void 0 ? nextMatch : matches[0];
            }
            return (_a = matches[0]) !== null && _a !== void 0 ? _a : undefined;
        };
        /* Handle typed input */
        // reset any typed value when an option is selected
        baseState.selectOption = function (ev, option) {
            setValue(undefined);
            selectOption(ev, option);
        };
        var onTriggerBlur = function (ev) {
            // handle selection and updating value if freeform is false
            if (!baseState.open && !freeform) {
                // select matching option, if the value fully matches
                if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.text.toLowerCase())) {
                    baseState.selectOption(ev, activeOption);
                }
                // reset typed value when the input loses focus while collapsed, unless freeform is true
                setValue(undefined);
            }
        };
        baseState.setOpen = function (ev, newState) {
            if (disabled) {
                return;
            }
            if (!newState && !freeform) {
                setValue(undefined);
            }
            setOpen(ev, newState);
        };
        // update value and active option based on input
        var onTriggerChange = function (ev) {
            var inputValue = ev.target.value;
            // update uncontrolled value
            baseState.setValue(inputValue);
            // handle updating active option based on input
            var matchingOption = getOptionFromInput(inputValue);
            setActiveOption(matchingOption);
            setFocusVisible(true);
            // clear selection for single-select if the input value no longer matches the selection
            if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || !matchingOption)) {
                clearSelection(ev);
            }
        };
        // open Combobox when typing
        var onTriggerKeyDown = function (ev) {
            if (!open && dropdownKeyActions_1.getDropdownActionFromKey(ev) === 'Type') {
                baseState.setOpen(ev, true);
            }
            // clear activedescendant when moving the text insertion cursor
            if (ev.key === keyboard_keys_1.ArrowLeft || ev.key === keyboard_keys_1.ArrowRight) {
                setHideActiveDescendant(true);
            }
            else {
                setHideActiveDescendant(false);
            }
        };
        // resolve input and listbox slot props
        var triggerSlot;
        var listboxSlot;
        triggerSlot = react_utilities_1.resolveShorthand(props.input, {
            required: true,
            defaultProps: tslib_1.__assign({ ref: react_utilities_1.useMergedRefs((_c = props.input) === null || _c === void 0 ? void 0 : _c.ref, triggerRef), type: 'text', value: value !== null && value !== void 0 ? value : '' }, triggerNativeProps),
        });
        triggerSlot.onChange = react_utilities_1.mergeCallbacks(triggerSlot.onChange, onTriggerChange);
        triggerSlot.onBlur = react_utilities_1.mergeCallbacks(triggerSlot.onBlur, onTriggerBlur);
        triggerSlot.onKeyDown = react_utilities_1.mergeCallbacks(triggerSlot.onKeyDown, onTriggerKeyDown);
        // only resolve listbox slot if needed
        listboxSlot =
            open || hasFocus
                ? react_utilities_1.resolveShorthand(props.listbox, {
                    required: true,
                    defaultProps: {
                        children: props.children,
                        style: popupDimensions,
                    },
                })
                : undefined;
        _a = useComboboxPopup_1.useComboboxPopup(props, triggerSlot, listboxSlot), triggerSlot = _a[0], listboxSlot = _a[1];
        _b = useTriggerListboxSlots_1.useTriggerListboxSlots(props, baseState, ref, triggerSlot, listboxSlot), triggerSlot = _b[0], listboxSlot = _b[1];
        if (hideActiveDescendant) {
            triggerSlot['aria-activedescendant'] = undefined;
        }
        var state = tslib_1.__assign({ components: {
                root: 'div',
                input: 'input',
                expandIcon: 'span',
                listbox: Listbox_1.Listbox,
            }, root: react_utilities_1.resolveShorthand(props.root, {
                required: true,
                defaultProps: tslib_1.__assign({ 'aria-owns': !inlinePopup ? listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id : undefined }, rootNativeProps),
            }), input: triggerSlot, listbox: listboxSlot, expandIcon: react_utilities_1.resolveShorthand(props.expandIcon, {
                required: true,
                defaultProps: {
                    'aria-expanded': open,
                    children: React.createElement(react_icons_1.ChevronDownRegular, null),
                    role: 'button',
                },
            }) }, baseState);
        state.root.ref = react_utilities_1.useMergedRefs(state.root.ref, rootRef);
        /* handle open/close + focus change when clicking expandIcon */
        var _h = state.expandIcon || {}, onIconMouseDown = _h.onMouseDown, onIconClick = _h.onClick;
        var onExpandIconMouseDown = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(onIconMouseDown, function () {
            // do not dismiss on blur when closing via clicking the icon
            if (open) {
                baseState.ignoreNextBlur.current = true;
            }
        }));
        var onExpandIconClick = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(onIconClick, function (event) {
            var _a;
            // open and set focus
            state.setOpen(event, !state.open);
            (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            // set focus visible=false, since this can only be done with the mouse/pointer
            setFocusVisible(false);
        }));
        if (state.expandIcon) {
            state.expandIcon.onMouseDown = onExpandIconMouseDown;
            state.expandIcon.onClick = onExpandIconClick;
            // If there is no explicit aria-label, calculate default accName attribute for expandIcon button,
            // using the following steps:
            // 1. If there is an aria-label, it is "Open [aria-label]"
            // 2. If there is an aria-labelledby, it is "Open [aria-labelledby target]" (using aria-labelledby + ids)
            // 3. If there is no aria-label/ledby attr, it falls back to "Open"
            // We can't fall back to a label/htmlFor name because of https://github.com/w3c/accname/issues/179
            var hasExpandLabel = state.expandIcon['aria-label'] || state.expandIcon['aria-labelledby'];
            var defaultOpenString = 'Open'; // this is english-only since it is the fallback
            if (!hasExpandLabel) {
                if (props['aria-labelledby']) {
                    var chevronId = (_d = state.expandIcon.id) !== null && _d !== void 0 ? _d : comboId + "-chevron";
                    var chevronLabelledBy = chevronId + " " + state.input['aria-labelledby'];
                    state.expandIcon['aria-label'] = defaultOpenString;
                    state.expandIcon.id = chevronId;
                    state.expandIcon['aria-labelledby'] = chevronLabelledBy;
                }
                else if (props['aria-label']) {
                    state.expandIcon['aria-label'] = defaultOpenString + " " + props['aria-label'];
                }
                else {
                    state.expandIcon['aria-label'] = defaultOpenString;
                }
            }
        }
        return state;
    };
    exports.useCombobox_unstable = useCombobox_unstable;
});
//# sourceMappingURL=useCombobox.js.map