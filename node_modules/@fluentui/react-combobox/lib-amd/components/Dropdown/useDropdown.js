define(["require", "exports", "tslib", "react", "@fluentui/react-icons", "@fluentui/react-utilities", "../../utils/dropdownKeyActions", "../../utils/useComboboxBaseState", "../../utils/useComboboxPopup", "../../utils/useTriggerListboxSlots", "../Listbox/Listbox", "@fluentui/react-utilities"], function (require, exports, tslib_1, React, react_icons_1, react_utilities_1, dropdownKeyActions_1, useComboboxBaseState_1, useComboboxPopup_1, useTriggerListboxSlots_1, Listbox_1, react_utilities_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDropdown_unstable = void 0;
    /**
     * Create the state required to render Dropdown.
     *
     * The returned state can be modified with hooks such as useDropdownStyles_unstable,
     * before being passed to renderDropdown_unstable.
     *
     * @param props - props from this instance of Dropdown
     * @param ref - reference to root HTMLElement of Dropdown
     */
    var useDropdown_unstable = function (props, ref) {
        var _a, _b;
        var baseState = useComboboxBaseState_1.useComboboxBaseState(props);
        var activeOption = baseState.activeOption, getIndexOfId = baseState.getIndexOfId, getOptionsMatchingText = baseState.getOptionsMatchingText, open = baseState.open, setActiveOption = baseState.setActiveOption, setFocusVisible = baseState.setFocusVisible, setOpen = baseState.setOpen;
        var _c = react_utilities_1.getPartitionedNativeProps({
            props: props,
            primarySlotTagName: 'button',
            excludedPropNames: ['children'],
        }), triggerNativeProps = _c.primary, rootNativeProps = _c.root;
        // set listbox popup width based off the root/trigger width
        var rootRef = React.useRef(null);
        var _d = React.useState(), popupWidth = _d[0], setPopupWidth = _d[1];
        React.useEffect(function () {
            var _a;
            var width = open ? ((_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) + "px" : undefined;
            setPopupWidth(width);
        }, [open]);
        // jump to matching option based on typing
        var searchString = React.useRef('');
        var _e = react_utilities_1.useTimeout(), setKeyTimeout = _e[0], clearKeyTimeout = _e[1];
        var getNextMatchingOption = function () {
            var _a;
            // first check for matches for the full searchString
            var matcher = function (optionText) { return optionText.toLowerCase().indexOf(searchString.current) === 0; };
            var matches = getOptionsMatchingText(matcher);
            var startIndex = activeOption ? getIndexOfId(activeOption.id) : 0;
            // if the dropdown is already open and the searchstring is a single character,
            // then look after the current activeOption for letters
            // this is so slowly typing the same letter will cycle through matches
            if (open && searchString.current.length === 1) {
                startIndex++;
            }
            // if there are no direct matches, check if the search is all the same letter, e.g. "aaa"
            if (!matches.length) {
                var letters_1 = searchString.current.split('');
                var allSameLetter = letters_1.length && letters_1.every(function (letter) { return letter === letters_1[0]; });
                // if the search is all the same letter, cycle through options starting with that letter
                if (allSameLetter) {
                    startIndex++;
                    matcher = function (optionText) { return optionText.toLowerCase().indexOf(letters_1[0]) === 0; };
                    matches = getOptionsMatchingText(matcher);
                }
            }
            // if there is an active option and multiple matches,
            // return first matching option after the current active option, looping back to the top
            if (matches.length > 1 && activeOption) {
                var nextMatch = matches.find(function (option) { return getIndexOfId(option.id) >= startIndex; });
                return nextMatch !== null && nextMatch !== void 0 ? nextMatch : matches[0];
            }
            return (_a = matches[0]) !== null && _a !== void 0 ? _a : undefined;
        };
        var onTriggerKeyDown = function (ev) {
            // clear timeout, if it exists
            clearKeyTimeout();
            // if the key was a char key, update search string
            if (dropdownKeyActions_1.getDropdownActionFromKey(ev) === 'Type') {
                // update search string
                searchString.current += ev.key.toLowerCase();
                setKeyTimeout(function () {
                    searchString.current = '';
                }, 500);
                // update state
                !open && setOpen(ev, true);
                var nextOption = getNextMatchingOption();
                setActiveOption(nextOption);
                setFocusVisible(true);
            }
        };
        // resolve button and listbox slot props
        var triggerSlot;
        var listboxSlot;
        triggerSlot = react_utilities_1.resolveShorthand(props.button, {
            required: true,
            defaultProps: tslib_1.__assign({ type: 'button', children: baseState.value || props.placeholder }, triggerNativeProps),
        });
        triggerSlot.onKeyDown = react_utilities_1.mergeCallbacks(onTriggerKeyDown, triggerSlot.onKeyDown);
        listboxSlot =
            baseState.open || baseState.hasFocus
                ? react_utilities_1.resolveShorthand(props.listbox, {
                    required: true,
                    defaultProps: {
                        children: props.children,
                        style: { width: popupWidth },
                    },
                })
                : undefined;
        _a = useComboboxPopup_1.useComboboxPopup(props, triggerSlot, listboxSlot), triggerSlot = _a[0], listboxSlot = _a[1];
        _b = useTriggerListboxSlots_1.useTriggerListboxSlots(props, baseState, ref, triggerSlot, listboxSlot), triggerSlot = _b[0], listboxSlot = _b[1];
        var state = tslib_1.__assign({ components: {
                root: 'div',
                button: 'button',
                expandIcon: 'span',
                listbox: Listbox_1.Listbox,
            }, root: react_utilities_1.resolveShorthand(props.root, {
                required: true,
                defaultProps: tslib_1.__assign({ 'aria-owns': !props.inlinePopup ? listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id : undefined, children: props.children }, rootNativeProps),
            }), button: triggerSlot, listbox: listboxSlot, expandIcon: react_utilities_1.resolveShorthand(props.expandIcon, {
                required: true,
                defaultProps: {
                    children: React.createElement(react_icons_1.ChevronDownRegular, null),
                },
            }), placeholderVisible: !baseState.value && !!props.placeholder }, baseState);
        state.root.ref = react_utilities_2.useMergedRefs(state.root.ref, rootRef);
        return state;
    };
    exports.useDropdown_unstable = useDropdown_unstable;
});
//# sourceMappingURL=useDropdown.js.map