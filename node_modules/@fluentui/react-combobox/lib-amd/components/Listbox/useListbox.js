define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/react-context-selector", "../../utils/dropdownKeyActions", "../../utils/useOptionCollection", "../../utils/useScrollOptionsIntoView", "../../utils/useSelection", "../../contexts/ComboboxContext"], function (require, exports, tslib_1, React, react_utilities_1, react_context_selector_1, dropdownKeyActions_1, useOptionCollection_1, useScrollOptionsIntoView_1, useSelection_1, ComboboxContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useListbox_unstable = void 0;
    /**
     * Create the state required to render Listbox.
     *
     * The returned state can be modified with hooks such as useListboxStyles_unstable,
     * before being passed to renderListbox_unstable.
     *
     * @param props - props from this instance of Listbox
     * @param ref - reference to root HTMLElement of Listbox
     */
    var useListbox_unstable = function (props, ref) {
        var multiselect = props.multiselect;
        var optionCollection = useOptionCollection_1.useOptionCollection();
        var getCount = optionCollection.getCount, getOptionAtIndex = optionCollection.getOptionAtIndex, getIndexOfId = optionCollection.getIndexOfId;
        var _a = useSelection_1.useSelection(props), clearSelection = _a.clearSelection, selectedOptions = _a.selectedOptions, selectOption = _a.selectOption;
        var _b = React.useState(), activeOption = _b[0], setActiveOption = _b[1];
        // track whether keyboard focus outline should be shown
        // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move
        var _c = React.useState(false), focusVisible = _c[0], setFocusVisible = _c[1];
        var onKeyDown = function (event) {
            var action = dropdownKeyActions_1.getDropdownActionFromKey(event, { open: true });
            var maxIndex = getCount() - 1;
            var activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
            var newIndex = activeIndex;
            switch (action) {
                case 'Select':
                case 'CloseSelect':
                    activeOption && selectOption(event, activeOption);
                    break;
                default:
                    newIndex = dropdownKeyActions_1.getIndexFromAction(action, activeIndex, maxIndex);
            }
            if (newIndex !== activeIndex) {
                // prevent default page scroll/keyboard action if the index changed
                event.preventDefault();
                setActiveOption(getOptionAtIndex(newIndex));
                setFocusVisible(true);
            }
        };
        var onMouseOver = function (event) {
            setFocusVisible(false);
        };
        // get state from parent combobox, if it exists
        var hasComboboxContext = react_context_selector_1.useHasParentContext(ComboboxContext_1.ComboboxContext);
        var comboboxActiveOption = react_context_selector_1.useContextSelector(ComboboxContext_1.ComboboxContext, function (ctx) { return ctx.activeOption; });
        var comboboxFocusVisible = react_context_selector_1.useContextSelector(ComboboxContext_1.ComboboxContext, function (ctx) { return ctx.focusVisible; });
        var comboboxSelectedOptions = react_context_selector_1.useContextSelector(ComboboxContext_1.ComboboxContext, function (ctx) { return ctx.selectedOptions; });
        var comboboxSelectOption = react_context_selector_1.useContextSelector(ComboboxContext_1.ComboboxContext, function (ctx) { return ctx.selectOption; });
        var comboboxSetActiveOption = react_context_selector_1.useContextSelector(ComboboxContext_1.ComboboxContext, function (ctx) { return ctx.setActiveOption; });
        // without a parent combobox context, provide values directly from Listbox
        var optionContextValues = hasComboboxContext
            ? {
                activeOption: comboboxActiveOption,
                focusVisible: comboboxFocusVisible,
                selectedOptions: comboboxSelectedOptions,
                selectOption: comboboxSelectOption,
                setActiveOption: comboboxSetActiveOption,
            }
            : {
                activeOption: activeOption,
                focusVisible: focusVisible,
                selectedOptions: selectedOptions,
                selectOption: selectOption,
                setActiveOption: setActiveOption,
            };
        var state = tslib_1.__assign(tslib_1.__assign({ components: {
                root: 'div',
            }, root: react_utilities_1.getNativeElementProps('div', tslib_1.__assign({ ref: ref, role: multiselect ? 'menu' : 'listbox', 'aria-activedescendant': hasComboboxContext ? undefined : activeOption === null || activeOption === void 0 ? void 0 : activeOption.id, 'aria-multiselectable': multiselect, tabIndex: 0 }, props)), multiselect: multiselect, clearSelection: clearSelection }, optionCollection), optionContextValues);
        var scrollContainerRef = useScrollOptionsIntoView_1.useScrollOptionsIntoView(state);
        state.root.ref = react_utilities_1.useMergedRefs(state.root.ref, scrollContainerRef);
        state.root.onKeyDown = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(state.root.onKeyDown, onKeyDown));
        state.root.onMouseOver = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(state.root.onMouseOver, onMouseOver));
        return state;
    };
    exports.useListbox_unstable = useListbox_unstable;
});
//# sourceMappingURL=useListbox.js.map