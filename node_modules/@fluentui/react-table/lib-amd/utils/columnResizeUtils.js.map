{"version":3,"file":"columnResizeUtils.js","sourceRoot":"","sources":["../../../../../../../../packages/react-components/react-table/src/utils/columnResizeUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { TableColumnDefinition, ColumnWidthState, TableColumnId, TableColumnSizingOptions } from '../hooks';\n\nconst DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */\n\nexport function columnDefinitionsToState<T>(\n  columns: TableColumnDefinition<T>[],\n  state: ColumnWidthState[] = [],\n  columnSizingOptions: TableColumnSizingOptions = {},\n): ColumnWidthState[] {\n  let updated = false;\n  const stateMap = new Map(state.map(s => [s.columnId, s]));\n\n  const updatedState = columns.map(column => {\n    const existingColumnState = stateMap.get(column.columnId);\n\n    if (existingColumnState) {\n      const {\n        idealWidth = existingColumnState.idealWidth,\n        minWidth = existingColumnState.minWidth,\n        padding = existingColumnState.padding,\n      } = columnSizingOptions[column.columnId] ?? {};\n\n      if (\n        idealWidth !== existingColumnState.idealWidth ||\n        minWidth !== existingColumnState.minWidth ||\n        padding !== existingColumnState.padding\n      ) {\n        updated = true;\n        return {\n          ...existingColumnState,\n          idealWidth,\n          width: idealWidth,\n          minWidth,\n          padding,\n        };\n      }\n      return existingColumnState;\n    }\n\n    const { defaultWidth, idealWidth = DEFAULT_WIDTH, minWidth = DEFAULT_MIN_WIDTH, padding } =\n      columnSizingOptions[column.columnId] ?? {};\n\n    updated = true;\n    return {\n      columnId: column.columnId,\n      width: Math.max(defaultWidth ?? idealWidth, minWidth),\n      minWidth,\n      idealWidth: Math.max(defaultWidth ?? idealWidth, minWidth),\n      padding: padding ?? 16,\n    };\n  });\n\n  // If the length of the new state changed (column was added or removed) or any of\n  // the individual states has a new reference (column was replaced),\n  // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n  // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n  if (updatedState.length !== state.length || updated) {\n    const column = updatedState.find(col => col.width > col.idealWidth);\n    if (column) {\n      column.width = column.idealWidth;\n    }\n\n    updated = true;\n  }\n\n  return updated ? updatedState : state;\n}\n\nexport function getColumnById(state: ColumnWidthState[], columnId: TableColumnId) {\n  return state.find(c => c.columnId === columnId);\n}\n\nexport function getColumnByIndex(state: ColumnWidthState[], index: number) {\n  return state[index];\n}\n\nexport function getTotalWidth(state: ColumnWidthState[]): number {\n  return state.reduce((sum, column) => sum + column.width + column.padding, 0);\n}\n\nexport function getLength(state: ColumnWidthState[]) {\n  return state.length;\n}\n\nexport function getColumnWidth(state: ColumnWidthState[], columnId: TableColumnId): number {\n  const column = getColumnById(state, columnId);\n  return column?.width ?? 0;\n}\n\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */\nexport function setColumnProperty(\n  localState: ColumnWidthState[],\n  columnId: TableColumnId,\n  property: keyof ColumnWidthState,\n  value: number,\n) {\n  const currentColumn = getColumnById(localState, columnId);\n\n  if (!currentColumn || currentColumn?.[property] === value) {\n    return localState;\n  }\n\n  const updatedColumn = { ...currentColumn, [property]: value };\n\n  const newState = localState.reduce((acc, current) => {\n    if (current.columnId === updatedColumn.columnId) {\n      return [...acc, updatedColumn];\n    }\n    return [...acc, current];\n  }, [] as ColumnWidthState[]);\n\n  return newState;\n}\n\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */\nexport function adjustColumnWidthsToFitContainer(state: ColumnWidthState[], containerWidth: number) {\n  let newState = state;\n  const totalWidth = getTotalWidth(newState);\n\n  // The total width is smaller, we are expanding columns\n  if (totalWidth < containerWidth) {\n    let difference = containerWidth - totalWidth;\n    let i = 0;\n    // We start at the beginning and assign the columns their ideal width\n    while (i < newState.length && difference > 0) {\n      const currentCol = getColumnByIndex(newState, i);\n      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n      newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n      difference -= colAdjustment;\n\n      // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n      if (i === newState.length - 1 && difference !== 0) {\n        const lastCol = getColumnByIndex(newState, i);\n        newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n      }\n\n      i++;\n    }\n  }\n\n  // The total width is larger than container, we need to squash the columns\n  else if (totalWidth >= containerWidth) {\n    let difference = totalWidth - containerWidth;\n    // We start with the last column\n    let j = newState.length - 1;\n    while (j >= 0 && difference > 0) {\n      const currentCol = getColumnByIndex(newState, j);\n      if (currentCol.width > currentCol.minWidth) {\n        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n        difference -= colAdjustment;\n        newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n      }\n      j--;\n    }\n  }\n\n  return newState;\n}\n"]}