define(["require", "exports", "tslib"], function (require, exports, tslib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.adjustColumnWidthsToFitContainer = exports.setColumnProperty = exports.getColumnWidth = exports.getLength = exports.getTotalWidth = exports.getColumnByIndex = exports.getColumnById = exports.columnDefinitionsToState = void 0;
    var DEFAULT_WIDTH = 150;
    var DEFAULT_MIN_WIDTH = 100;
    /**
     * This function takes the column definitions and the curent ColumnWidthState and returns new state.
     *  - It uses existing state for existing columns.
     *  - It removes any state for columns no longer present.
     *  - It checks if any column has been replaced and returns updated state if so
     *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)
     * @param columns
     * @param state
     * @returns
     */
    function columnDefinitionsToState(columns, state, columnSizingOptions) {
        if (state === void 0) { state = []; }
        if (columnSizingOptions === void 0) { columnSizingOptions = {}; }
        var updated = false;
        var stateMap = new Map(state.map(function (s) { return [s.columnId, s]; }));
        var updatedState = columns.map(function (column) {
            var _a, _b;
            var existingColumnState = stateMap.get(column.columnId);
            if (existingColumnState) {
                var _c = (_a = columnSizingOptions[column.columnId]) !== null && _a !== void 0 ? _a : {}, _d = _c.idealWidth, idealWidth_1 = _d === void 0 ? existingColumnState.idealWidth : _d, _e = _c.minWidth, minWidth_1 = _e === void 0 ? existingColumnState.minWidth : _e, _f = _c.padding, padding_1 = _f === void 0 ? existingColumnState.padding : _f;
                if (idealWidth_1 !== existingColumnState.idealWidth ||
                    minWidth_1 !== existingColumnState.minWidth ||
                    padding_1 !== existingColumnState.padding) {
                    updated = true;
                    return tslib_1.__assign(tslib_1.__assign({}, existingColumnState), { idealWidth: idealWidth_1, width: idealWidth_1, minWidth: minWidth_1, padding: padding_1 });
                }
                return existingColumnState;
            }
            var _g = (_b = columnSizingOptions[column.columnId]) !== null && _b !== void 0 ? _b : {}, defaultWidth = _g.defaultWidth, _h = _g.idealWidth, idealWidth = _h === void 0 ? DEFAULT_WIDTH : _h, _j = _g.minWidth, minWidth = _j === void 0 ? DEFAULT_MIN_WIDTH : _j, padding = _g.padding;
            updated = true;
            return {
                columnId: column.columnId,
                width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
                minWidth: minWidth,
                idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
                padding: padding !== null && padding !== void 0 ? padding : 16,
            };
        });
        // If the length of the new state changed (column was added or removed) or any of
        // the individual states has a new reference (column was replaced),
        // we have to reset the column widths to their ideal width (because the column which was last may not be last now).
        // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.
        if (updatedState.length !== state.length || updated) {
            var column = updatedState.find(function (col) { return col.width > col.idealWidth; });
            if (column) {
                column.width = column.idealWidth;
            }
            updated = true;
        }
        return updated ? updatedState : state;
    }
    exports.columnDefinitionsToState = columnDefinitionsToState;
    function getColumnById(state, columnId) {
        return state.find(function (c) { return c.columnId === columnId; });
    }
    exports.getColumnById = getColumnById;
    function getColumnByIndex(state, index) {
        return state[index];
    }
    exports.getColumnByIndex = getColumnByIndex;
    function getTotalWidth(state) {
        return state.reduce(function (sum, column) { return sum + column.width + column.padding; }, 0);
    }
    exports.getTotalWidth = getTotalWidth;
    function getLength(state) {
        return state.length;
    }
    exports.getLength = getLength;
    function getColumnWidth(state, columnId) {
        var _a;
        var column = getColumnById(state, columnId);
        return (_a = column === null || column === void 0 ? void 0 : column.width) !== null && _a !== void 0 ? _a : 0;
    }
    exports.getColumnWidth = getColumnWidth;
    /**
     * This function takes the current state and returns an updated state, so that it can be set.
     * The reason for this is that we can update the state multiple times before commiting to render.
     * This is an optimization and also prevents flickering.
     * It also returns new copy of the state only if the value is different than the one currently in
     * the state, further preventing unnecessary updates.
     * @param localState
     * @param columnId
     * @param property
     * @param value
     * @returns
     */
    function setColumnProperty(localState, columnId, property, value) {
        var _a;
        var currentColumn = getColumnById(localState, columnId);
        if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {
            return localState;
        }
        var updatedColumn = tslib_1.__assign(tslib_1.__assign({}, currentColumn), (_a = {}, _a[property] = value, _a));
        var newState = localState.reduce(function (acc, current) {
            if (current.columnId === updatedColumn.columnId) {
                return tslib_1.__spreadArray(tslib_1.__spreadArray([], acc), [updatedColumn]);
            }
            return tslib_1.__spreadArray(tslib_1.__spreadArray([], acc), [current]);
        }, []);
        return newState;
    }
    exports.setColumnProperty = setColumnProperty;
    /**
     * This function takes the state and container width and makes sure the each column in the state
     * is its optimal width, and that the columns
     * a) fit to the container
     * b) always fill the whole container
     * @param state
     * @param containerWidth
     * @returns
     */
    function adjustColumnWidthsToFitContainer(state, containerWidth) {
        var newState = state;
        var totalWidth = getTotalWidth(newState);
        // The total width is smaller, we are expanding columns
        if (totalWidth < containerWidth) {
            var difference = containerWidth - totalWidth;
            var i = 0;
            // We start at the beginning and assign the columns their ideal width
            while (i < newState.length && difference > 0) {
                var currentCol = getColumnByIndex(newState, i);
                var colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);
                newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);
                difference -= colAdjustment;
                // if there is still empty space, after all columns are their ideal sizes, assign it to the last column
                if (i === newState.length - 1 && difference !== 0) {
                    var lastCol = getColumnByIndex(newState, i);
                    newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);
                }
                i++;
            }
        }
        // The total width is larger than container, we need to squash the columns
        else if (totalWidth >= containerWidth) {
            var difference = totalWidth - containerWidth;
            // We start with the last column
            var j = newState.length - 1;
            while (j >= 0 && difference > 0) {
                var currentCol = getColumnByIndex(newState, j);
                if (currentCol.width > currentCol.minWidth) {
                    var colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);
                    difference -= colAdjustment;
                    newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);
                }
                j--;
            }
        }
        return newState;
    }
    exports.adjustColumnWidthsToFitContainer = adjustColumnWidthsToFitContainer;
});
//# sourceMappingURL=columnResizeUtils.js.map