define(["require", "exports", "tslib", "@fluentui/react-utilities"], function (require, exports, tslib_1, react_utilities_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTableSortState = exports.useTableSort = exports.defaultTableSortState = void 0;
    var noop = function () { return undefined; };
    exports.defaultTableSortState = {
        getSortDirection: function () { return 'ascending'; },
        setColumnSort: noop,
        sort: function (rows) { return tslib_1.__spreadArray([], rows); },
        sortColumn: undefined,
        sortDirection: 'ascending',
        toggleColumnSort: noop,
    };
    function useTableSort(options) {
        // False positive, these plugin hooks are intended to be run on every render
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return function (tableState) { return useTableSortState(tableState, options); };
    }
    exports.useTableSort = useTableSort;
    function useTableSortState(tableState, options) {
        var columns = tableState.columns;
        var sortState = options.sortState, defaultSortState = options.defaultSortState, onSortChange = options.onSortChange;
        var _a = react_utilities_1.useControllableState({
            initialState: {
                sortDirection: 'ascending',
                sortColumn: undefined,
            },
            defaultState: defaultSortState,
            state: sortState,
        }), sorted = _a[0], setSorted = _a[1];
        var sortColumn = sorted.sortColumn, sortDirection = sorted.sortDirection;
        var toggleColumnSort = function (e, columnId) {
            setSorted(function (s) {
                var newState = tslib_1.__assign(tslib_1.__assign({}, s), { sortColumn: columnId });
                if (s.sortColumn === columnId) {
                    newState.sortDirection = s.sortDirection === 'ascending' ? 'descending' : 'ascending';
                }
                else {
                    newState.sortDirection = 'ascending';
                }
                onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
                return newState;
            });
        };
        var setColumnSort = function (e, nextSortColumn, nextSortDirection) {
            var newState = { sortColumn: nextSortColumn, sortDirection: nextSortDirection };
            onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
            setSorted(newState);
        };
        var sort = function (rows) {
            return rows.slice().sort(function (a, b) {
                var sortColumnDef = columns.find(function (column) { return column.columnId === sortColumn; });
                if (!(sortColumnDef === null || sortColumnDef === void 0 ? void 0 : sortColumnDef.compare)) {
                    return 0;
                }
                var mod = sortDirection === 'ascending' ? 1 : -1;
                return sortColumnDef.compare(a.item, b.item) * mod;
            });
        };
        var getSortDirection = function (columnId) {
            return sortColumn === columnId ? sortDirection : undefined;
        };
        return tslib_1.__assign(tslib_1.__assign({}, tableState), { sort: {
                sort: sort,
                sortColumn: sortColumn,
                sortDirection: sortDirection,
                setColumnSort: setColumnSort,
                toggleColumnSort: toggleColumnSort,
                getSortDirection: getSortDirection,
            } });
    }
    exports.useTableSortState = useTableSortState;
});
//# sourceMappingURL=useTableSort.js.map