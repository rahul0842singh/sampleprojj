define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "./selectionManager"], function (require, exports, tslib_1, React, react_utilities_1, selectionManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTableSelectionState = exports.useTableSelection = exports.defaultTableSelectionState = void 0;
    var noop = function () { return undefined; };
    exports.defaultTableSelectionState = {
        allRowsSelected: false,
        clearRows: noop,
        deselectRow: noop,
        isRowSelected: function () { return false; },
        selectRow: noop,
        selectedRows: new Set(),
        someRowsSelected: false,
        toggleAllRows: noop,
        toggleRow: noop,
        selectionMode: 'multiselect',
    };
    function useTableSelection(options) {
        // False positive, these plugin hooks are intended to be run on every render
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return function (tableState) { return useTableSelectionState(tableState, options); };
    }
    exports.useTableSelection = useTableSelection;
    function useTableSelectionState(tableState, options) {
        var items = tableState.items, getRowId = tableState.getRowId;
        var selectionMode = options.selectionMode, defaultSelectedItems = options.defaultSelectedItems, selectedItems = options.selectedItems, onSelectionChange = options.onSelectionChange;
        var _a = react_utilities_1.useControllableState({
            initialState: new Set(),
            defaultState: defaultSelectedItems,
            state: selectedItems,
        }), selected = _a[0], setSelected = _a[1];
        var selectionManager = React.useMemo(function () {
            return selectionManager_1.createSelectionManager(selectionMode, function (e, newSelectedItems) {
                setSelected(function () {
                    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(e, { selectedItems: newSelectedItems });
                    return newSelectedItems;
                });
            });
        }, [onSelectionChange, selectionMode, setSelected]);
        var toggleAllRows = react_utilities_1.useEventCallback(function (e) {
            selectionManager.toggleAllItems(e, items.map(function (item, i) { var _a; return (_a = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _a !== void 0 ? _a : i; }), selected);
        });
        var toggleRow = react_utilities_1.useEventCallback(function (e, rowId) {
            return selectionManager.toggleItem(e, rowId, selected);
        });
        var deselectRow = react_utilities_1.useEventCallback(function (e, rowId) {
            return selectionManager.deselectItem(e, rowId, selected);
        });
        var selectRow = react_utilities_1.useEventCallback(function (e, rowId) {
            return selectionManager.selectItem(e, rowId, selected);
        });
        var isRowSelected = function (rowId) {
            return selectionManager.isSelected(rowId, selected);
        };
        return tslib_1.__assign(tslib_1.__assign({}, tableState), { selection: {
                selectionMode: selectionMode,
                someRowsSelected: selected.size > 0,
                allRowsSelected: selectionMode === 'single' ? selected.size > 0 : selected.size === items.length,
                selectedRows: selected,
                toggleRow: toggleRow,
                toggleAllRows: toggleAllRows,
                clearRows: selectionManager.clearItems,
                deselectRow: deselectRow,
                selectRow: selectRow,
                isRowSelected: isRowSelected,
            } });
    }
    exports.useTableSelectionState = useTableSelectionState;
});
//# sourceMappingURL=useTableSelection.js.map