"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTableColumnResizeMouseHandler = void 0;
const React = /*#__PURE__*/require("react");
const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
function useTableColumnResizeMouseHandler(columnResizeState) {
  const mouseX = React.useRef(0);
  const currentWidth = React.useRef(0);
  const colId = React.useRef(undefined);
  const {
    targetDocument
  } = react_shared_contexts_1.useFluent_unstable();
  const globalWin = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const recalculatePosition = React.useCallback(e => {
    const {
      clientX
    } = react_utilities_1.getEventClientCoords(e);
    const dx = clientX - mouseX.current;
    // Update the local width for the column and set it
    currentWidth.current += dx;
    colId.current && columnResizeState.setColumnWidth(e, {
      columnId: colId.current,
      width: currentWidth.current
    });
    mouseX.current = clientX;
  }, [columnResizeState]);
  const onDrag = React.useCallback(e => {
    // Using requestAnimationFrame here drastically improves resizing experience on slower CPUs
    if (typeof (globalWin === null || globalWin === void 0 ? void 0 : globalWin.requestAnimationFrame) === 'function') {
      requestAnimationFrame(() => recalculatePosition(e));
    } else {
      recalculatePosition(e);
    }
  }, [globalWin === null || globalWin === void 0 ? void 0 : globalWin.requestAnimationFrame, recalculatePosition]);
  const onDragEnd = React.useCallback(event => {
    if (react_utilities_1.isMouseEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('mouseup', onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('mousemove', onDrag);
    }
    if (react_utilities_1.isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('touchend', onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('touchmove', onDrag);
    }
  }, [onDrag, targetDocument]);
  const getOnMouseDown = columnId => event => {
    // Keep the width locally so that we decouple the calculation of the next with from rendering.
    // This makes the whole experience much faster and more precise
    currentWidth.current = columnResizeState.getColumnWidth(columnId);
    mouseX.current = react_utilities_1.getEventClientCoords(event).clientX;
    colId.current = columnId;
    if (react_utilities_1.isMouseEvent(event)) {
      // ignore other buttons than primary mouse button
      if (event.target !== event.currentTarget || event.button !== 0) {
        return;
      }
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('mouseup', onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('mousemove', onDrag);
    }
    if (react_utilities_1.isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('touchend', onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('touchmove', onDrag);
    }
  };
  return {
    getOnMouseDown: columnId => getOnMouseDown(columnId)
  };
}
exports.useTableColumnResizeMouseHandler = useTableColumnResizeMouseHandler;
//# sourceMappingURL=useTableColumnResizeMouseHandler.js.map