define(["require", "exports", "./debounce", "./priorityQueue"], function (require, exports, debounce_1, priorityQueue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createOverflowManager = void 0;
    /**
     * @internal
     * @returns overflow manager instance
     */
    function createOverflowManager() {
        var container;
        var overflowMenu;
        // Set as true when resize observer is observing
        var observing = false;
        // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change
        var forceDispatch = false;
        var options = {
            padding: 10,
            overflowAxis: 'horizontal',
            overflowDirection: 'end',
            minimumVisible: 0,
            onUpdateItemVisibility: function () { return undefined; },
            onUpdateOverflow: function () { return undefined; },
        };
        var overflowItems = {};
        var overflowGroups = {};
        var resizeObserver = new ResizeObserver(function (entries) {
            if (!entries[0] || !container) {
                return;
            }
            update();
        });
        var invisibleItemQueue = priorityQueue_1.createPriorityQueue(function (a, b) {
            var itemA = overflowItems[a];
            var itemB = overflowItems[b];
            // Higher priority at the top of the queue
            var priority = itemB.priority - itemA.priority;
            if (priority !== 0) {
                return priority;
            }
            var positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;
            // equal priority, use DOM order
            // eslint-disable-next-line no-bitwise
            return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;
        });
        var visibleItemQueue = priorityQueue_1.createPriorityQueue(function (a, b) {
            var itemA = overflowItems[a];
            var itemB = overflowItems[b];
            // Lower priority at the top of the queue
            var priority = itemA.priority - itemB.priority;
            if (priority !== 0) {
                return priority;
            }
            var positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;
            // equal priority, use DOM order
            // eslint-disable-next-line no-bitwise
            return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;
        });
        var getOffsetSize = function (el) {
            return options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;
        };
        var makeItemVisible = function () {
            var nextVisible = invisibleItemQueue.dequeue();
            visibleItemQueue.enqueue(nextVisible);
            var item = overflowItems[nextVisible];
            options.onUpdateItemVisibility({ item: item, visible: true });
            if (item.groupId) {
                overflowGroups[item.groupId].invisibleItemIds.delete(item.id);
                overflowGroups[item.groupId].visibleItemIds.add(item.id);
            }
            return getOffsetSize(item.element);
        };
        var makeItemInvisible = function () {
            var nextInvisible = visibleItemQueue.dequeue();
            invisibleItemQueue.enqueue(nextInvisible);
            var item = overflowItems[nextInvisible];
            var width = getOffsetSize(item.element);
            options.onUpdateItemVisibility({ item: item, visible: false });
            if (item.groupId) {
                overflowGroups[item.groupId].visibleItemIds.delete(item.id);
                overflowGroups[item.groupId].invisibleItemIds.add(item.id);
            }
            return width;
        };
        var dispatchOverflowUpdate = function () {
            var visibleItemIds = visibleItemQueue.all();
            var invisibleItemIds = invisibleItemQueue.all();
            var visibleItems = visibleItemIds.map(function (itemId) { return overflowItems[itemId]; });
            var invisibleItems = invisibleItemIds.map(function (itemId) { return overflowItems[itemId]; });
            var groupVisibility = {};
            Object.entries(overflowGroups).forEach(function (_a) {
                var groupId = _a[0], groupState = _a[1];
                if (groupState.invisibleItemIds.size && groupState.visibleItemIds.size) {
                    groupVisibility[groupId] = 'overflow';
                }
                else if (groupState.visibleItemIds.size === 0) {
                    groupVisibility[groupId] = 'hidden';
                }
                else {
                    groupVisibility[groupId] = 'visible';
                }
            });
            options.onUpdateOverflow({ visibleItems: visibleItems, invisibleItems: invisibleItems, groupVisibility: groupVisibility });
        };
        var processOverflowItems = function () {
            if (!container) {
                return false;
            }
            var availableSize = getOffsetSize(container) - options.padding;
            var overflowMenuOffset = overflowMenu ? getOffsetSize(overflowMenu) : 0;
            // Snapshot of the visible/invisible state to compare for updates
            var visibleTop = visibleItemQueue.peek();
            var invisibleTop = invisibleItemQueue.peek();
            var visibleItemIds = visibleItemQueue.all();
            var currentWidth = visibleItemIds.reduce(function (sum, visibleItemId) {
                var child = overflowItems[visibleItemId].element;
                return sum + getOffsetSize(child);
            }, 0);
            // Add items until available width is filled - can result in overflow
            while (currentWidth < availableSize && invisibleItemQueue.size() > 0) {
                currentWidth += makeItemVisible();
            }
            // Remove items until there's no more overflow
            while (currentWidth > availableSize && visibleItemQueue.size() > 0) {
                if (visibleItemQueue.size() <= options.minimumVisible) {
                    break;
                }
                currentWidth -= makeItemInvisible();
            }
            // make sure the overflow menu can fit
            if (visibleItemQueue.size() > options.minimumVisible &&
                invisibleItemQueue.size() > 0 &&
                currentWidth + overflowMenuOffset > availableSize) {
                makeItemInvisible();
            }
            // only update when the state of visible/invisible items has changed
            if (visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop) {
                return true;
            }
            return false;
        };
        var forceUpdate = function () {
            if (processOverflowItems() || forceDispatch) {
                forceDispatch = false;
                dispatchOverflowUpdate();
            }
        };
        var update = debounce_1.debounce(forceUpdate);
        var observe = function (observedContainer, userOptions) {
            Object.assign(options, userOptions);
            observing = true;
            Object.values(overflowItems).forEach(function (item) { return visibleItemQueue.enqueue(item.id); });
            container = observedContainer;
            resizeObserver.observe(container);
        };
        var disconnect = function () {
            observing = false;
            resizeObserver.disconnect();
        };
        var addItem = function (item) {
            if (overflowItems[item.id]) {
                return;
            }
            overflowItems[item.id] = item;
            // some options can affect priority which are only set on `observe`
            if (observing) {
                // Updates to elements might not change the queue tops
                // i.e. new element is enqueued but the top of the queue stays the same
                // force a dispatch on the next batched update
                forceDispatch = true;
                visibleItemQueue.enqueue(item.id);
            }
            if (item.groupId) {
                if (!overflowGroups[item.groupId]) {
                    overflowGroups[item.groupId] = {
                        visibleItemIds: new Set(),
                        invisibleItemIds: new Set(),
                    };
                }
                overflowGroups[item.groupId].visibleItemIds.add(item.id);
            }
            update();
        };
        var addOverflowMenu = function (el) {
            overflowMenu = el;
        };
        var removeOverflowMenu = function () {
            overflowMenu = undefined;
        };
        var removeItem = function (itemId) {
            if (!overflowItems[itemId]) {
                return;
            }
            var item = overflowItems[itemId];
            visibleItemQueue.remove(itemId);
            invisibleItemQueue.remove(itemId);
            if (item.groupId) {
                overflowGroups[item.groupId].visibleItemIds.delete(item.id);
                overflowGroups[item.groupId].invisibleItemIds.delete(item.id);
            }
            delete overflowItems[itemId];
            update();
        };
        return {
            addItem: addItem,
            disconnect: disconnect,
            forceUpdate: forceUpdate,
            observe: observe,
            removeItem: removeItem,
            update: update,
            addOverflowMenu: addOverflowMenu,
            removeOverflowMenu: removeOverflowMenu,
        };
    }
    exports.createOverflowManager = createOverflowManager;
});
//# sourceMappingURL=overflowManager.js.map