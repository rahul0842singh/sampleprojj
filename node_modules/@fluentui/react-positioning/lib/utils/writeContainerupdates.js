import { DATA_POSITIONING_ESCAPED, DATA_POSITIONING_HIDDEN, DATA_POSITIONING_INTERSECTING, DATA_POSITIONING_PLACEMENT } from '../constants';
/**
 * Writes all container element position updates after the position is computed
 */
export function writeContainerUpdates(options) {
  var _a, _b, _c;
  const {
    container,
    placement,
    middlewareData,
    strategy,
    lowPPI,
    coordinates
  } = options;
  if (!container) {
    return;
  }
  container.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
  container.removeAttribute(DATA_POSITIONING_INTERSECTING);
  if (middlewareData.intersectionObserver.intersecting) {
    container.setAttribute(DATA_POSITIONING_INTERSECTING, '');
  }
  container.removeAttribute(DATA_POSITIONING_ESCAPED);
  if ((_a = middlewareData.hide) === null || _a === void 0 ? void 0 : _a.escaped) {
    container.setAttribute(DATA_POSITIONING_ESCAPED, '');
  }
  container.removeAttribute(DATA_POSITIONING_HIDDEN);
  if ((_b = middlewareData.hide) === null || _b === void 0 ? void 0 : _b.referenceHidden) {
    container.setAttribute(DATA_POSITIONING_HIDDEN, '');
  }
  // Round so that the coordinates land on device pixels.
  // This prevents blurriness in cases where the browser doesn't apply pixel snapping, such as when other effects like
  // `backdrop-filter: blur()` are applied to the container, and the browser is zoomed in.
  // See https://github.com/microsoft/fluentui/issues/26764 for more info.
  const devicePixelRatio = ((_c = container.ownerDocument.defaultView) === null || _c === void 0 ? void 0 : _c.devicePixelRatio) || 1;
  const x = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
  const y = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
  Object.assign(container.style, {
    transform: lowPPI ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`,
    position: strategy
  });
}
//# sourceMappingURL=writeContainerupdates.js.map